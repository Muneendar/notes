<<<<<<< HEAD
C C++ Java are the programming languages.. JDBC JSP Servlet JavaMail JTA(Java Transcation API) JPA(JAVA Persistence API) JMS(Java Messaging Service) are the 

Technologies...Struts Spring Hibernate etcc.. are the java frameworks

Programming Languages:
--------------------

It is directly installed software & it is base for creating the software appplications...Defines the semantics and syntaxes for Programming.

Technologies Frameworks Tools Db software and OS are bulitin on the top of the programming languages..

Software Technology: It provides the Set of rules and guideliness to devlop the software using the programming language support...Software technology is not installable but the software created following the guidlenss & rules of the technology are the installable...Working with this software is nothing but the working with this software technologies..

In Java environment technogy rules are nothing but Interfaces...Classes provide the guideliness and abstract classes provide the both rules & guideliness

Software Technology is one Jar we can call API jar... Imeplemntation of technologies by vendors  provide another JAR.. We should use both of them inorder to work with the software..

Java Provide the JDBC API rules and guideliness to provide the implementation of Driver classes.. Working with the Drivers is nothing but working with JDBC 
technologies....

JDBC Technology... JDBC Drivers(Softwares)

Open Technologies and Proprietary Technologies:

Rules and guideliness of technology are open to all software vendor compaines to develop the software...Examples are all the Java Technologies

Proprietary Technologies::Venodr companies who has given the technologies are allow to develop the software based on the technology.. Microsoft Technologies


Frameworks:
----------

Framework is a installable software that uses the existing technolgies internally to simplify the application development having the ability to generate the common logics of the application internally.. Framework is the installable software that provides the abstraction layer on the existing technologies to simplify the application development process..

While developing the applications using the Software Technologies/(Softwraes impl) programmer has to develop the both the common logics and specific logics of the application..While working with frameworks the programmer has to develop only the application specific logics because the common logics will be generated by the framework dynamically...

Even the framework uses the technology internally but it never makes the progrmmaer to know about it.. This is nothing but providing the abstarction layerr..(hiding the implementations/internals)

Hibernate uses the JDBC Driver Softwares generates the logics dynamically and makes the application development process simplify..

While working with only Software Technology we need to write the common logics and application specific logics..Common logics are called as Boiler plate code.. Frameworks take care of all the Boiler Plate code..

Based on the kind of the applications and logics we develop there are 3 types of the Java Frameworks..

WebApplication Framework:
-------------------------
Provides the abstraction layer on the servlets and JSP technology.. Simplifies the MV architecure based web application development..

JSF,ADF-->Oracle  Struts-->Apache 	WebWork-->OpenSymphony   - Spring MVC-->Interface 


ORM Framework:
-------------

Provides the abstraction layer on the JDBC technology.. Simplifies the Object based O-R mapping persistence logic development..Allows the portability/DB independent persistence logic devlopment..

Hibernate--> RedHat   TOPLINK--->ORACLE  OJB,IBatis-->Apache  JDO--->Adobe

We not required to build the queries.. IF we build queries when we change the DB then queries may not be compatabile.. So we should depend on the framework to build the queries.. Allows for the Object oriented style of building the queires..


Application Framework:
---------------------

Provides the abstraction layer on multiple technologies like JDBC servlets JSP JNDI JMS JTA JPA JavaMail EJB RMI etc.. Allows to develop the all kinds of the logic like the business logic,persistenc logic,presentation logic, integeration logic.. Allows to develop all kinds of the applications like the standalone applications webapplications distributed applications..

Based on the mode of development there are two kinds of Frameworks:
------------------------------------------------------------------

Invasive Framewrok:: Here the classes of the application has to extends or implement from the Framewrok api classes/interfaces. This process makes the application classes as tightly coupled classes of the framework.. We cannot change the Framework of application/project by just changing the libraries..

Non Invasive Framework:Here the classes of the application need not has to extends or implement from the Framewrok api classes/interfaces.so our application classes are not tightly bound with framework..We can change the framwork of the application/project by just changing the libraries(jar files)


Evaluation of Spring:
---------------------

Applets -->For Gaming	1995
Java Bean---> for Blogic/Service logic development 1996
Disadvanatges:: Can't apply the services, can't be acessed from remote clients

Security transactions logging Connection pooling etcc are called the service/middleware services..

EJB---> Used for Busines logic and services logic development

Advantages:: Allows both local and remote clients.. Allows to apply the middleware services..

Disadvantage:: Hevay Weight and Complex.. EJB is suitable for the Banking Projects


Spring(2003):: Intially used for the Business/Services logics development with ordinary classes allowing to apply the middleware servicess..Now spring can be used to develop all kinds of appplication logics in light weight environment and allowing to apply the middleware services..

IS spring is replacement for the STRUTS? Using the struts we can develop only the web applications .. there is no provision in struts to develop and use the middleware services/aspects(Security logging etc..) Using Spring we can develop all kinds of the applications and all kinds of the logics..

Spring acts as UMBERALLA/Abstraction over all the JAVA technologies to devlop the applications with all kinds of logics like logging/security/transcation/
aop in Hassle free manner with avoiding the all Boiler Plate code..


***Spring is providing abstraction layer even on the Frameworks like Hibernate Toplink Ibatis JDO OJB JPA ADF JSF Struts WebWork RichViewSupport Jasperreports FreeMarker Excel PDF Spring Portlet MVC

Spring Core:: This module is base for all the modules,designed for supporting the dependency injection(injecting values to objects dynamically)

Spring JDBC: Provides the abstraction over the plain jdbc to simplify the jdbc style persistence logic development and exception rethrowing concept is used to design the DAOException hirerachy

SPRING ORM: Provides the abstraction layer on the multiple ORM framework like Hibernate and simplifies the Object Based ORMapping Peristence logic

SPring Web: Provides the plugin to make the spring applications communicatble from other web framework applications like Struts,JSF and etcc..applications

Spring Web MVC: Springs own framework to develop the MVC architecture based webapplications with plain classes and aribitary methods of classes

Spring Context: Provides the abstraction layer on the multiple JSE and JEE module technologies to simplify the development of the common logics..

Mailing Applications, Distribution Applications, Messaging Applications and scheduling Applications etc...

Spring AOP: Provides the new Methodlogy of programming to develop aspect/middleware service logics and apply them on the Spring Applications...

Before AOP:

Class Bank{

	public void withdraw(){
		
	//Security Logic
	//Logging Logic
	//Transcation Logic
	//withdraw logic
	
	}

	public void deposit(){
		
	//Security Logic
	//Logging Logic
	//Transcation Logic
	//Deposit logic
	
	}
}

With AOP:

Class Bank{

	public void withdraw(){
		
	//withdraw logic
	
	}

	public void deposit(){
		
	//Deposit logic
	
	}
}

Spring 3.x is compatabile with 1.5 and Spring 4.x with jdk 1.6 & supports all the features of Java8.

Spring 4.x Messaging a subframework in Spring 4.x is given alternate to the JMS to get the messages based asynchronous communications between the components..Asynchronous commmunications allow the client to give next request or the client side operations wiht out giving the response for current request from server.. 

WebSocket is the weblevel protocol that is designed on the top http protocol for full 2 way communication..


M-->Model-> Data + Business Logic + Persistence Logic
V--> View -->Presentation logic
C-->Controller-->Integration Logic

Integration logic controls and monitors all activities of application execution.. It is responsible to get communication between the view layer and model layer componenets

DAO:: The java class that seprates the persistence logics from another logics and makes the persistence logics as the reusable and flexible logic to modify is called as DAO

JDBC is light weight but doesnot allow to develop the Object Based Persistence logic..EJB entity Beans are heavy but allows to develop the object based persistence logic.. To overcome the both probelms we can use the Hibernate...

EJBSessionBeans are completely replaced with the help of the Spring JEE/Beans/SpringWebServices..With the help of all the Middleware service logics Secuirty logging Transcations etcc.. being implemented

Spring Definition:
-----------------

Spring is the OpenSource, Light Weight, loosely coupled,aspect oriented,dependency injection based java application framework to develop the various java applications..

What is Opensource?Not only freesoftware they also expose the source code.. Along with installation we get source code container jar files..

LightWeight: Spring gives the 2 light weight containers which can be activated anywhere in the application...To work with spring we dont need the any webserver software or the application server..

We can use the specific modules of Spring without having any link with other modules..We can use the Spring Core alone or the SpringCore + Spring DAO module together without anylink with other modules..If the dependency is less between the modules, then they are called as Loosely coupled components 

In the Spring framework Spring CORE module is the base module for all the modules..We should use every module along with Spring Core module..That is only dependency..But remaining modules can be used alone without having dependency with any other modules.. So dependency is very less between all the modules..
This makes the spring as loosely coupled framework

AOP is the new methodlogy of programming that compliments the OOP to seprate the secondary middleware service logics from the Primary Business logics and allows them to link dynamically at runtime through some configuration. This gives the advanatges of reusable middleware service logics and flexibility of enabling and disabling middleware service logics on primary logics(like security and transcations etc...)

Dependency LookUp:
------------------

If the resource/class/Object is searching and getting the dependent values from other resources then it is called as dependency Lookup..Here the resource itself pulls the dependent values..

-->The way we get the Objects from JNDI registry is called Dependency LookUp..The way we get JDBC connection Objects from Connection pool

Dependency Injection(Inversion of Control):
------------------------------------------

If the underlying framework/server/container/runtime(JRE)  assigns the values to resource/classes/Objects dynamically at runtime then it is called Dependency Injection..Here the dependent values are pushed to the resource..

Examples:JVM calling the constructor automatically to assign the intial values of Object when the Object is created..Servlet Container injects the servlet config Object once the servlet instance is created..


POJO Class: Ordinary java class that is not extending from the any techonloy/framework api class or not implementing the any technology/framework api interfaces is called as POJO class

Ex: class Demo{} class Test implements Serializable{} class Test extends Demo{} class Test extends Thread{}---->POJO examples

class Test extends HttpServlet{} class Test Implements java.sql.Connection{}---->NON POJO examples

class Test{
	void m1(Statement st){}  Test is POJO class
}

class Demo implements java.rmi.Remote{}  class Test extends Demo{}---->Both the Demo & Test are not POJO classess

@Entity
class Test{} Test is POJO class


Don't consider the Annotations and APIS used inside the methods of class to check whether the class is POJO or not...



23-02-2021:
----------
POJI: Plain Old Java Interface It indicates the interface without specialities (ordinary interfaces) not extending from the technology/framework Interfaces

The frameworks that supports the POJO/POJI model programming is called as Non Invasive Frameworks or LightWeight Frameworks

Ex: Hibernate Spring and Struts 2.x

JavaBean:
--------

The javaclass that is developed with some standards..Must be the public class and should not be final or abstract class. Can be implementing Serializable interface if need.. Must have Zero Param constructor direct or indircet..Every Bean property should have setter & getters

In realtime javabean is used as the Helper class to represent the data with multiple values in the form of Object and send those Objects from one layer to another layer. It is the accpetable format irrespective of the technologies used in the Multiple layers..

The JavaBean class whose Object holds the input values given by the client/enduser is called VOClass...The java bean class which holds the data needed for the persistence operations is called BOClass.The javabean class object which holds the data that is shippable across the network is called DTO class...

BeanClass/ComponentClass:
------------------------

The javaclass that contains member varaibles and methods having the business logic manipulating the data of member varaibles..

Class CardProcesser{

private int cardNo;

public int processCard(int cardNo){-----BLogic-------}

public boolean blockCard(int cardNo){-------BLogic---------}

}

Bean/Component class can extend or implement the any Framewrok Class/Interface..

SpringBean:
----------

The javaclass whose Object can be managed by the SpringContainer is called SpringBean..Spring Bean can be POJO/JavaBeanClass..

Bean/Component class whose object is created/maintained by the spring container can also be called as the Spring Bean..

We can't take the Interfaces/Abstract classes as the springBeans because we cannot create the Objects of the Interfaces/Abstract classes..Spring Bean can be the userdefined/predefined or third Party classes..

Any F/w class or any class that is extending the F/w class can be called as the SpringBeans

Sprin Bean can be Pojo Class? Yes 
Every Java Bean is a Pojo class? Yes
Every Pojo class is javabean? No
Every Spring Bean is javaBEan?NNo
Spring bean can be JavaBean ? Yes
Spring Bean cannot implement the Spring API Interfaces? No
ANy Component class can be taken as the Spring Bean ? Yes

Spring Container:
----------------

Any javaclass or application that can manage the life cycle of given reosurces(springbeans) is called the container..

BeanFactory:Perfoms the spring beans management and Dependency injection

Application COntext:: Internally uses the BeanFactory so can perfom the advnaced operations along with the  spring beans management and Dependency injection

Spring containers are light weight but not alternative for the Servlets/JSP containers (Heavy Weight)

BeanDactory factory=new XMLBeanFcatory(Resource:To xml spring bean confiuration file)

						Spring CORE MODULE:

Talks about the Spring Bean Lifecycle managemet and dependency Injection..When it is used alone we can develop the standAlone Applications..When used along with other technologies we can develop model layer business logic by taking the advntage of the dependency Injection..

Talks about the Spring Bean lifecycle Management and Dependency Injection..


Dependency Injection(Inversion of Control):
------------------------------------------

If the underlying framework/server/container/runtime(JRE)  assigns the values to resource/classes/Objects dynamically at runtime then it is called Dependency Injection..Here the dependent values are pushed to the resource.

Setter Injection:: Container uses the zero param const for creating the bean clss object and calls the setter method to inject the dependent value
Constructor Injection: Container uses the Parameterized constructor to create the bean class Object and inject the values
Interface Injection
Method Injection
Lookup Injection

Any file name can be taken as Spring Configuration file.. but it is recommended to take the applicationContext.xml file in StandAlone applications

In SpringBean configuration file: we configure the SpringBeans the Dependency injection configuration and SpringBean lifecycle configuration etcc...

We must supply the springbean configuration file while activating the SpringContainer..Every Spring bean is identified by its bean id(used for dependency injection with ref property)

<property> tag perfoms the setter injection..

public class WishMessageGenerator {

private String name;
private  Date  date;

setter;getter

}

<bean id="dt" class="java.util.Date"></bean>
 <bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/>

Setter Injection: Spring uses the zero param cons to create the Objects of Date class and WishMessageGenerator..

Constructor Injection: Spring uses the zero param cons to create DateClass Object and two param constr for the WishMessageGenerator

<bean id="dt" class="java.util.Date"></bean>
 <bean id="wmg" class="com.beans.WishMessageGenerator">
  <constructor-arg value="Raja"/>
 <constructor-arg ref="dt"/>
 </bean>

 res=new FileSystemResource("src/main/java/com/cfgs/applicationContext.xml");
		 //create BeanFactory IOC container
		BeanFactory factory=new XmlBeanFactory(res);
		 //get Target bean class object
		 Object obj=factory.getBean("wmg");
		 //typecasting
		WishMessageGenerator generator=(WishMessageGenerator)obj;
		 //invoke the  method
		 result=generator.generateWishMessage();


Note:: Every Spring Bean should have unique Id.. We can also configure the same class with multiple Ids..

Dependencies:
------------
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-context</artifactId>
<version>5.3.4</version>
</dependency>

aop beans context core expression jcl(logging) jars will be downloaded...

Steps::

1) checks whether xml file is wellformed and valid document or not 2)Creates the empty logical IOC container in jvm memory
2) Creates the SaxParser to read the xml file data and maintain it as inmemory metadata or inmemomry configuration...
3) factory=new XmlBeanFactory(res); returns the XmlBeanFactory Object representing IOC container
4) factory.getBean("wmg",WishMessageGenerator.class); For the "wmg" id inmemory data configuration is looked and Loads the WishMessageGenerator class into    JVM.. class.forName("WishMessageGenerator.class").newInstance();
5) Looks the <property> tag with name and calls the setter method in the WishMessageGenerator class instance
6) Looks the <property> tag with date and identifies the dependency Object DateClass.. It loads the DateClass Create Objects and calls setter method on 
  WishMessageGenerator class to inect the date Object...

						newInstance Method:
						------------------	

Class c1=Class.forName(args[0]); loads the given class and return the java.lang.Class Object..  static flow is executed here..ClassNotFoundException thrown
Object obj1=c1.newInstance();	 Creates the Object of the Class...zero Param constructor is executed here..When we create the Object below exception are thrown..InstantiationException(If underlying class is abstract/interface), IllegalAccessException(for Private COnstructor)
				
public T newInstance(Object... initargs)
  throws InstantiationException, IllegalAccessException,
         IllegalArgumentException, InvocationTargetException

Parameters: This method accepts initargs as the parameter which is an array of objects to be passed as arguments to the constructor call. The values of primitive types are wrapped in a wrapper object of the appropriate type (e.g. float in Float)

Return value: This method returns a new object created by calling the constructor this object represents.

Exception: This method throws following Exceptions:

IllegalAccessException: if this Constructor object is enforcing Java language access control and the underlying constructor is inaccessible.
IllegalArgumentException: if the number of actual and formal parameters differ; if an unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a parameter value cannot be converted to the corresponding formal parameter type by a method invocation conversion; if this constructor pertains to an enum type.
InstantiationException: if the class that declares the underlying constructor represents an abstract class.
InvocationTargetException: if the underlying constructor throws an exception.
ExceptionInInitializerError: if the initialization provoked by this method fails.

 public static void main(String... args)  throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException 
    { 
          // An array of constructor 
        Constructor[] constructor = Test.class.getConstructors(); 
          // Apply newInstance method 
        Test sampleObject = (Test)constructor[0].newInstance(); Invoke the constructor
          System.out.println(sampleObject.value); 
    } 

class Test { 
  
    String value; 
  
    public Test() 
    { 
        System.out.println("New Instance is created"); 
        value = "New Instance"; 
    } 
} 

Constructor[] constructor = Test.class.getConstructors(); or use the class.forName
Test sampleObject = (Test)constructor[0] .newInstance("New Field"); Passing the parameter to the Single Param Constructor

If we configure the both setter and constructor injections then the bean property values given by the setter injection will remain final values becuase the setter method executes aftre the execution of constructor injection..

<bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/> 
 <constructor-arg value="Raja"/>		Object is created only with Two Param Constructor.. Setter Methods will be used for injecting values
 <constructor-arg ref="dt"/>			again...
 </bean>

Order: Constructor Injection followed by Setter Injection... Object is created only once.. not created in the both cases..

If the spring bean class is configured without injections or only with setter Injection(for one/more) properties then container uses the 0-param constructor
If any property is configured for the constructor injection then it uses the parameterized constructor to create the bean class Object

public class WishMessageGenerator {

private String name;
private static Date  date;
	
public WishMessageGenerator(String name,Date date) {
		
		System.out.println("Wish Message generator:: Two Param Cons");
		this.name=name;
		this.date=date;
	}

	public static void setDate(Date date) {
		System.out.println("WishMessageGenerator:: setDate(-)");
		WishMessageGenerator.date = date;
	}
	
	public void setName(String name) {
		System.out.println("WishMessageGenerator:: setname(-)");
		this.name = name;
	}
}

We can also take the static properties also for creating the springbeans..

bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/>				You can perfom the constructor injection or the setter Injection
<!-- <constructor-arg value="Raja"/>
 <constructor-arg ref="dt"/>
  --></bean>

What is difference between the FileSystemResource and ClassPathResource?

Can locate the given springbean file from the specified path of file system..Here we can pass the absolute path or the relative path..

ClassPathResource can locate the spring bean file from the dircetories/jar files that are added to classpath/buildpath..

ClassPathResurce resource=new ClassPathResource("applicationContext.xml")--->Finds the xml file from jar or classpath.


HAS-A relationship:

Createing the dependent class object in the target class and using..

Limitations::Instead of the DTDC courier if flipkart wants the another courier we need to modify the target class.. If the delivery() changed to supply() in DTDC class then also the filipkart class code needs to be modified
>TightCoupling

Using the Help of Factory class to create the Objects and using the Factory class as dependent in Flipkart(Target Class):
If the flipkart wants to use the BlueDart it needs the BlueDartFactory and if it needs DTDC then Flipkart class has to change to DTDCFactory Class
>Same as first approach.. TightCoupling is observed..

Approach3:

class Flipkart{
	
	public void purchase(){
	
	IntialContext ic=new IntialContext();  DTDC dtdc=(DTDC)ic.lookup("cr"); dtdc.deliver();
	
	}
}

If the Flipkart wants the BuleDart Object instead of DTDC object we need to place that object in JNDI registry..
>Same as the first approach.. tight coupling

Approach 4: Flipkart class extending from the DTDC class.

class DTDC{
	deliver(){}
}

class Flipkart extends DTDC{

	purchase(){
		deliver();
}

}

Flipkart class cannot extends more than one dependent class... In order to change we need to change the flipkart class to extend BlueDart Class.. 
>Same as first approach.. We need to change the FlipKart Class.


Approach 5: Making the underlying container to inject dependent Objet to target Object..Using the dependency Injection(setter/constructor injection)


The approach 5 is similar to approach 1& 2 only difference is the underlying container is managing the dependency in the approach5 where as the programmer is managing the dependency in the approach 1 & 2

Limitations: Approach 5 is good towards the mangaing the dependecy injection but inorder to achieve the loose coupling we shouldn't directly work with dependent class in the target class..it is recommended to make all the dependent classes implementing the one common interface having the common method declaration.So that we start using this common interface in the target class


In the flipkart class we are not working with the implementation class directly we are workign with the interface varaible so the underlying can be able to inject any implemntation class Object without chainging/touching the source code of the FlipKart(TargetClass.) We Mark @Primary on the implementation class Objects without touching the Target classes.. If it is the Predefined beans then we have touch the target using the @Qualifer() to change the beanName..

To achieve the loosely coupling in Spring we use the : Dependency Injection & POJI Model programming


In the Spring Bean File::

<property name="msg" value="Hello"/> can be written as the <property name="msg"><value>Hello</value></property>

<property name="date" ref="dt"/> can be written as the <property name="date"><ref bean="dt"/></property> <property name="date"><ref local="dt"/></property>


Design Patterns:
---------------

Which comes as the best solution for the reoccurreing problems of the application devlopment..Design patterns are the best practisces for utilizing the software language technologies and Frameworks effectively in the application development..

Strategy Pattern: While developing the multiple classes having the dependency it is recommended to follow this Design pattern..This pattern is not a spring pattern, it can be used anywhere since spring manages the dependency between the classes, it is recommended to use this pattern while developing the spring application....Strategy pattern is all about implementing the 3 principles.

1) Prefer the composition(HAS-A) over inheritance
2) Always code for the interface never code for the implementation classes---->Loose Coupling
3) Code should be open for the extension and closed for modfication

If the one class creates the Object of other class to use its logics then it is called as the implementation..(HAS-A relationship)

What are the disadvantages of the Inheritance? It doesn't support the multiple inheritances and code becomes easily breakable

Code must be open for the extension and must be closed for the modification:
----------------------------------------------------------------------------

If we follow the second principle perfectly by taking the methods of implementation classes A& B our code becomes closed for the modification and open for the extension..Similary it allows the more implementation classes for interface x having the new logics...This makes the code open for the extension


Flipkart class wants the logics of the DTDC class or blueDart class, but it is not inheriting from those classes but getting the objects of those classes through composition.. BlueDart ,DTDC classes are implementing the Courier(I) or their objects are assigned to Flipkart class through Courier(I)

By making the delivery() method of BlueDart or DTDC class as final methods we can keep that code closed for the modificaton and we can develop the new implementation class for the COurier(I). If the new Courier service like FirstFlight is required for the Flipkart class


Inside the static Block exception should be thrrown:: They need to be Handled properly using the try catch..


How to configure the Factory as the Bean?

	private int sno;
	private String sname;
	private String sadd;
	private  float avg;
	
public Student(int sno, String sname, String sadd, float avg) {
	    System.out.println("Student:: 4-param constructor");
		this.sno = sno;
		this.sname = sname;
		this.sadd = sadd;
		this.avg = avg;
	}

If Bean is configured like this then::

 <bean id="stud"  class="com.nt.comps.Student">
       <!--  <constructor-arg value="1001"/>
        <constructor-arg  value="raja"/>
        <constructor-arg  value="hyd"/> -->
        <constructor-arg value="56.77f"/>	String can't be converted to int
</bean>
UnsatisfiedDependencyException: Error creating bean with name 'stud' \src\main\java\com\nt\cfgs\applicationContext.xml]: Unsatisfied dependency expressed through constructor parameter 0: Could not convert argument value of type [java.lang.String] to required type [int]: Failed to convert value of type 

Resolving the Constructor Params: 

Resolving/Identifying the Params in Constructor Injection:
----------------------------------------------------------

We generally configure the dependent values of constructor injection in the order the paramas of constructor are avilable..But we can mismatch this order during the configuration if we can identify the params using the index type or name.. before Spring 3.x only

<constructor-arg value="" type="float/int/string"/>  <constructor-arg value="" index=""/> 

Based on index:

 <bean id="mk"  class="com.nt.beans.Marks">
       <constructor-arg  index="2" value="70"/>
       <constructor-arg index="1"  value="80"/>
       <constructor-arg  index="0"  value="90"/>
    </bean>

Based on Type:

<bean id="emp"  class="com.nt.beans.Employee">
        <constructor-arg value="raja"  type="java.lang.String"/>
        <constructor-arg  value="1001" type="int"/>
        <constructor-arg value="60000.55f"  type="float"  index="0" name="salary"/>
    </bean>
    
Based on Name:
@ConstructorProperties({"no","fname","sub"})  public con(int no,String fname,String sub)
<constructor-arg value="" name=""/>

In Spring 3.x can't get the parameter names of constructor directly until the parameter names of constructor directly configured using 
@ConstructorProperties({"no","fname","sub"})

in Spring 4.x IOC container can recognise the constructor parameter names directly ..

<bean id="st"  class="com.nt.beans.Student">
        <constructor-arg name="total"  value="270"/>
        <constructor-arg name="sno"  value="342"/>
        <constructor-arg name="sname" value="karan"/>
        <constructor-arg name="sadd"  value="hyd"/>
    </bean>



Cyclic Dependency: If two beans are dependent on each other then we can say that they are in the cyclic dependency.. Spring container can't perfom the cyclic dependency injection through the constructor injection but can perfom through the setter injection

<bean id="a1" class="com.nt.beans.A">
<constructor-arg ref="b1" />
</bean>

<bean id="b1" class="com.nt.beans.B">
<constructor-arg ref="a1" />						
</bean>

a1=factory.getBean("a1",A.class);

Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b1' defined in file applicationContext.xml]: Cannot resolve reference to bean 'a1' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a1': Requested bean is currently in creation: Is there an unresolvable circular reference?
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:342)


To solve this error we should follow setterInjection on the both the classes...

We can also perfom the Cyclic dependncy vy taking one bean class with the setter Injection & other Bean class with Constructor Injection..

<bean id="a1" class="com.nt.beans.A">
	<!-- <property name="b" ref="b1"></property> -->   
		<constructor-arg ref="b1" />
	</bean>

	<bean id="b1" class="com.nt.beans.B">
		<!-- <constructor-arg ref="a1" /> -->
		<property name="a" ref="a1"></property>
	</bean>


a1=factory.getBean("a1",A.class); You cannot do like this till will still be CyclicDependency error..

<bean id="a1" class="com.nt.beans.A">
<property name="b" ref="b1"></property>
<!-- <constructor-arg ref="b1" /> -->
</bean>
<bean id="b1" class="com.nt.beans.B">
<constructor-arg ref="a1" />
<!-- <property name="a" ref="a1"></property> -->
</bean>

a1=factory.getBean("a1",A.class); if you have to call the other bean the you need to reverse the configuration...so better take the Setter Injection on the both the Beans that is the Best Approach

When We should go for the setter Injection and when to go for the constructor Injection:
----------------------------------------------------------------------------------------

IF the bean class contains only one property or all the properties of the bean class should participate in the Dependency Injetction then go for the constructor injection..Because the constructor injection is faster

If the bean class contains N no:of Properties & no need of making all the properties to participate in the Dependency Injection go for the setter Injection..

Ex:In the above case if you have to go with the constructor injection then we should make n! no:of constructors to support the constructor injection in all the ways...


Difference bettwen the setter & Constructor Injection:: Bean class Object created using the zero param constructor..Bean class object created using the single/multiple param constructor....Cyclic Dependency is supported using the setter injection.. Not supported using the constructor injection

perfoms the injection after the creation of the bean class Object..So it is bit delayed..perfoms the injection while creating the bean class Object so there is no delay in injection

Inner Bean:
---------

Placing the <bean> tag inside the <property> or <constructor-arg> tag..If you want to use the certain bean as the Dependent bean for only one Target class then configure as the Inner Bean other wise configure as the Normal Bean...Inner Beans cannot be accessed from Client App..BeanId is also not required to configure..

<bean id="paymentGwBean" class="com.java2novice.beans.PaymentGateway">
        <constructor-arg>
           <bean class="com.java2novice.beans.Order">
                <property name="item" value="Java2Novice" />
                <property name="price" value="RS 22.50" />
                <property name="address" value="Bangalore" />
            </bean> 
        </constructor-arg>
    </bean>



<bean id="kohli"  class="com.nt.beans.ProffesionalCrickter">  <!-- outer bean cfg -->
        <constructor-arg value="virat kohli"/>
         <constructor-arg name="bat">  
             <bean    class="com.nt.beans.CricketBat"/>  <!--  inner bean cfg-->
         </constructor-arg>
     </bean>
     
     
     <bean id="dhoni"  class="com.nt.beans.ProffesionalCrickter">
        <constructor-arg value="dhoni"/>
         <constructor-arg name="bat">  
             <bean  class="com.nt.beans.CricketBat"/>
         </constructor-arg>
     </bean>



Limitations of the Inner Bean :: 

1) Inner Bean cannot be used as dependent bean for the multiple other beans.. 2)Inner Bean Object cannot be accessed from the client Applications

Can we configure the SpringBean class with out Bean iD?

Yes container generates the default bean id using the notation...<pkg>.<BeanClassName>#n   n=0,1,2,3.....

<bean class="com.nt.beans.Flipkart"></bean> BeanId will be  com.nt.beans.Flipkart#0

Configuring the springbean with the beanid is not mandatory but it is recommendation.. 

******Note:
In spring applications we cannot make the IOC conatiner to inject the end user supplied values to beans properties..All these configurations are dependency management related congigurations..

Spring Supports the Dependency Injection On Following Properties:
--------------------------------------------------------------

1)Simple Properties Primitive DataTypes and String's  use the value attr or <value>	
2) Refrence/Object Type properties ref attr or <ref>..We need to configure the dependent datatYpe first and then configure
3) Collection Properties (Array	<list> 	List	<list> 	Set	<set> 	Map	<map> Properties	<props>)

By using the tags internally Objects will be created just we need to assign the values..

private List<String> names;private String[] names;<list><value></value><value></value></list>

private Set<String> phoneNums;<set><value></value><value></value></set>

private Map<String,String> facultySubjects;  <map><entry key=""><value></value></entry> <map><entry key="" value=""></entry>

<map><entry><key><value></value></key><value></value></entry>

******Instead of <value> tag you can use the <ref> if you have the beans in List Set Map..<ref bean="sysdate"/>

Properties Allows Key& value pairs as the Strings..

<property name="empDesgs">
<props>
<prop key="Anil">Clerk</prop>
<prop key="Anil">SE</prop>
</props>
</property>

Checkout the example of NaatrazSir  IOCProj12-CollectionInjection

Injecting the Null Values:	Useful in cons injec when all the values need to injected and for the certain ref type property and we cannot proevide the value

<constructor-arg name="something"><null/></constructor-arg>

but in the setter injection we can avoid it without configuring it..Null is automatically Injected..


Bean Inheritance:
---------------- 

We use the inheritance for the reusability and extensibility.Bean inheritance is no way related with the class level physical inheritance..It is all about the xml file level bean configurations inheritance..

When we want to configure the same class Multiple times as the Spring Beans we can reuse of bean properties configuration across the multiple beans configurations


<bean id="pulsor1" class="com.beans.Bike">
<property name="id" value="TS080111"/>
<property name="make" value="Bajaj"/>
<property name="engineCC" value="150"/>
</bean>

<bean id="pulsor2" class="com.beans.Bike">
<property name="id" value="TS0802222"/>
<property name="make" value="Bajaj"/>
<property name="engineCC" value="150"/>    Here we are setting the same values for the two beans
</bean>

Solution::

<bean id="base" class="com.beans.Bike" abstract="true">
<property name="make" value="Bajaj"/>				----->Common Reusable properties..
<property name="engineCC" value="150"/>
</bean>

<bean id="pulsor1" class="com.beans.Bike" parent="base">
<property name="id" value="TS02222"/>  
</bean>

<bean id="pulsor1" class="com.beans.Bike" parent="base">
<property name="id" value="TS03333"/>
</bean>

Note:The abstract doesn't the bean class as the abstract but makes that configuration as the Abstract...We can't use that bean in the Client application....

Important Points:: Parent Bean configuration & child bean configuration can refer to the same class or the different classes..(Like Parent & Child physical classes)

Bean Inheritance using the Constructor:
---------------------------------------

	<bean id="baseCar" class="com.nt.beans.Car" abstract="true">
		<constructor-arg name="engineCC" value="1500" />
		<constructor-arg name="model" value="swift" />
		<constructor-arg name="company" value="suzuki" />
		<constructor-arg name="fuelType" value="diesle" />
		<constructor-arg name="owner" value="raja" />
		<!-- <constructor-arg name="type" value="hatchback" /> -->
		<constructor-arg name="type"><null/></constructor-arg>

	</bean>

	<bean id="rajaCar1" class="com.nt.beans.Car" parent="baseCar">
		<constructor-arg name="regNo" value="TS07EN4345" />
		<constructor-arg name="engineNo" value="12345" />
		<constructor-arg name="color" value="red" />
	</bean>

	<bean id="rajaCar2" class="com.nt.beans.Car" parent="baseCar">
		<constructor-arg name="regNo" value="TS07EN4344" />
		<constructor-arg name="engineNo" value="56789" />
		<constructor-arg name="color" value="white" />
		<constructor-arg name="owner" value="rani" />
	</bean>




RealtimeDI for the BeanInheritance: 
-----------------------------------

<!-- Configiure DataSource -->
	<bean id="oraDrds"	class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName"		value="oracle.jdbc.driver.OracleDriver" />
		<!-- <property name="url"			value="jdbc:oracle:thin:@localhost:1521:xe"  /> -->
		 <property name="username" value="system" />
		<property name="password" value="manager" /> 
	</bean>
	
	<bean id="oraScds"  class="org.springframework.jdbc.datasource.SingleConnectionDataSource"   parent="oraDrds"/>
	
	<bean id="oraHkDs"  class="com.zaxxer.hikari.HikariDataSource" parent="oraDrds">
	     <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:xe"/>
	     <property name="minimumIdle" value="10"/>   <!-- min pool size -->
	     <property name="maximumPoolSize" value="20"/>
	     <property name="connectionTimeout"  value="2000"/>
	</bean>
	
	<bean id="mysqlDrds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
		<property name="url" value="jdbc:mysql:///ntsp713db" />
		<property name="username" value="root" />
		<property name="password" value="root" />
	</bean>

	<!-- cfg DAO class -->
	<bean id="oraCustDAO" class="com.nt.dao.OracleCustomerDAOImpl">
		<!-- <constructor-arg ref="oraDrds" /> -->
		<!-- <constructor-arg ref="oraScds"/> -->
		 <constructor-arg  ref="oraHkDs"/>
	</bean>

	<bean id="mysqlCustDAO" class="com.nt.dao.MysqlCustomerDAOImpl">
		<constructor-arg ref="mysqlDrds" />
	</bean>



	<!-- cfg service class -->
	<bean id="custService"		class="com.nt.service.CustomerMgmtServiceImpl">
		<!-- <constructor-arg ref="mysqlCustDAO" /> -->
		<constructor-arg ref="oraCustDAO"/>
	</bean>

	<!-- cfg Controller class -->
	<bean id="controller" class="com.nt.controller.MainController">
		<constructor-arg ref="custService" />
	</bean>


								Collection Merging:
								------------------


It allows to merge the values set to the Base Bean configuration collection property with the values set to ChildBean Configuration collection property using the merge="true"

<bean id="base1stYear"  class="com.nt.beans.EnggCourse"  abstract="true">
         <property name="subjects">
              <list>
		<value>C</value><value>Maths</value>
	      </list>
	</property>

<bean id="ECE1styear"  class="com.nt.beans.EnggCourse"  parent="base1stYear">
        <property name="subjects">
              <list>
		<value>C</value><value>Digital Elctronics</value><value>Maths</value>
	      </list>
	</property>
<value>

Writing the common configurations again in the child bean configurations indicates the duplication..

Solution:

<bean id="ECE1styear"  class="com.nt.beans.EnggCourse"  parent="base1stYear">
        <property name="subjects">
              <list merge="true">
		<value>Digital Elctronics</value>
	      </list>
	</property>
<value>

1)Merging is possible only on the collection type property.. 
2) Base Bean configuration Collection type and child bean configuration collection type must match to perfom the merging


								Bean Alias:
								-----------

Alias name is nick-name or petname.. It is all about providing more alternative names/id's to use the bean.. Prior to spring 2.0 name attribute is given to provide the "alias name" from spring 2.0 <alias> tag is introduced for the same... We can use both the name attribute and <alias> tag to provide the alias name from Spring 2.0

<bean id="system" name="pc,desktop" class="com.nt.beans.Computer"/>
<alias name="system" alias="machine"/>
<alias name="system" alias="box"/>

<alias> tag is recommended to use because it allows to provide the alias names to multiple beans in the single place..Aliasing is useful in the maintenance mode of the bean configuration where we can short the alias name for the lengthy  bean ids..

factory.getBean("box") factory.getBean("pc") factory.getBean("system") factory.getBean("desktop")


Dependency LookUp:

If TargetClass wnats to use the dependent Object in all methods of the target class then we should use the Dependency Injection...

If the Target Class wants to use the dependent objects only inside the certain methods of target classes then use the Dependency Lookup..

Engine Dependent class need to be used only inside the move method of Vechile class..So we go for the Dependency Lookup code inside the move method of Vechile class..

If the Target Bean Class of Spring app wants to use the external services components gathered from the JNDI rgistry like getting the scoreComponent ref,getting the whether report component etc.. go for the dependency Lookup


public class Vechile {
	
	private String engineId;				//Bean Id is the String value
	
	public Vechile() {
		System.out.println("Vechicle class zero param constructor()");
	}
	
	public void setEngineId(String engineId) {
		this.engineId = engineId;
	}
	public String getEngineId() {
		return engineId;
	}
	

	public void move() {
		
		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);------>Factory is created Here and Factory will  also be created 											inside	TestClass
		reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		
		Engine engine = factory.getBean(getEngineId(),Engine.class);
		
		engine.start();
		
	}
}	

<bean id="engine" class="com.nt.beans.Engine" />
	<bean id="vechile" class="com.nt.beans.Vechile">
	<property name="engineId" value="engine"/>
	</bean>

Using the value attribute in above configuration beanId value will be passed directly without checking whether any such bean with Id exists or not.. To avoid that and perfom the intial check then we should use the <idref bean="engine"/>

<property name="engineId"><idref bean="engine"/>


								FactoryMethod:	
								--------------

The method that is capable of creatinng either the same class object or different class Object is called as Fcatory Method..

There are two types of Factory Methods:

Instance FActory Method:
-----------------------

String s1=new String("Hello");
String s2=s1.concat("123"); // hello 123 (returns the same class Object)

StringBuffer sb=new StringBuffer("Hello How are you?");
String s1=sb.substring(0,4);// Hello				Gives the different class Object


Static Factory Method:
----------------------

Class c=Class.forName("java.util.Date");(Returns the same class Object)
Console console=System.console();	(Returns the different class Object)

We can make the IOC conatiner to create the Spring Bean class Obect using the 4 ways:

1) Using the 0-param Constructor(When the no properties are configured for the dependency Injection and when only setter injection is enabled)
2) Using the parameterized constructor(When atleast one property is configured for the constructor injection)
3) Using the instance Fcatory method
4) Using the static factory Method

*****Servlet Conatiner,JSp Container can create the bean class Object by using the Zero Param Constructor..
*****But SpringContainer can create the SpringBeans objects in the above mentioned 4 ways..

***In Spring we can configure the Abstract Class as Spring Bean only when we enable the factory-method instantiantion

Static Factory Methods:
----------------------

<bean id="c1" class="java.lang.Class" factory-method="forName">  
<constructor-arg value="java.util.Date/"> "Not for the constructor injection this is given for passing the argument value to the forName method"
</bean>

<bean id="c2" class="java.util.Calendar" factory-method="getInstance"/>

Instance Factory Methods:
------------------------

<bean id="s1" class="java.lang.String">
<constructor-arg value="hello"/>		for the constructor injection
</bean>

<bean id="s2" factory-bean="s1" factory-method="concat">
<constructor-arg value="how are you?"
</bean>

<bean id="sb" class="java.lang.StringBuffer">
<constructor-arg value="hello how are you?"/>		
</bean>

<bean id="s3" factory-bean="sb" factory-method="substring">
<constructor-arg value="0"/>
<constructor-arg value="5"/>		
</bean>
 

SingleTon Java Class:
--------------------

The java class that allows us to create only one object per JVM is called as the Singleton class Java class

Take the singleton java class in the following situations:

If the class is not having any state..If class is having only sharable readonly state(static final varaibles)..If the class is having huge amount of data and perfoming the write operations on the state in the synchronized manner (1 thread at a time)

Instead of creating the multiple objects with the same data or no data, create one object and access it for multiple times for this take the class as the Singleton Java class

If we just create the for java class even thought the class allows us to create the multiple Objects then that class is not the singleton java class

Eg:: Our Servlet class is not Singleton class but it allows us to create the multiple Objects but it most of the times servlet container creates only one Object


Bean Scopes:
------------

Spring 1.x :: Singleton ProtoType

Spring 2.x:: Singleton ProtoType session request globalSession... globalSession scope is removed from the Spring 3.x

Singleton: Returns the same bean class Object for the factory.getBean() method calls with the same bean id..

ProtoType: Returns the seprate bean class Object for the every factory.getBean() method calls

Request: Bean class Object is specific to each request..

Session: Bean class Object is visible through out the session

Scope attribute of the <bean > tag specifies the bean scope..

Cache: It is the temporary memory that holds the data for the temporary period[Buffer]...If the DAO class uses the cache support it maintains the database data like Countries info and uses them across the multiple same request and reduce the no:of hits to the database software..

Are the Cache & Session meant to hold the same kind of the data? NO.. Sessions store the client information where as the Cache's stores the Buffered data that needs to be accessed acrosss the multiple same requests..


** Note: The Bean scope singleton never makes our bean class as the Singleton java class...But gives the singleton behaviour while creating the Object..

IF bean scope is Singleton then the IOC container creates the bean class Object and keeps in HashMap object element as the value by having the bean 'id' as the key and uses that Object across the multiple factory.getBean() method calls..

If the bean scope is ProtoType then the IOC container doesn't keep the created bean class Object in the HashMap so it returns the new Object for every factory.getBean() call

If the scope is "request" then the bean Object will be maintained as the request attribute..If the scope is "Session" then bean object will be maintained as the session attribute..


Bean Wiring:
------------

Configuring the beans and their dependency injection in the Spring Bean configuration file is called as the Wiring..

Explicit Wiring: Here we use the <property>,<constructor-args> for the dependency injection configuration

AutoWiring: Here IOC container automatically detects the dependents and injects then to the target Objects..Here no <property> <constructor-args> are required..


AutoWiring/Implicit Wiring Limitations:
--------------------------------------

Can be used as only to to inject Objects but not the simple values...If the IOC container has multiple dependencies to inject then ambiguity problem may raise.. Kills the readability of the xmlfile, so the bug fixing becomes much complex.

By using the autowire attribute of the bean tag we can enable the autowiring.. There are 4 modes of perfoming the autowiring

1)ByName 2)ByType 3)constructor 4)autodetect

autowire="byName"
---------------
Perfoms the setter injection.. For all the target class property names & dependent class bean id must match..There is no possibility of getting the ambiguity problem..

autoWire="byType"
----------------
*Perfoms the setter injectiom...For this target class property type and dependent class type must be match or must be compatabile with each other..There is possibility of getting the ambiguity problem..


autoWire="constructor"
---------------------

Uses the parameterized constructor to perfom the constructor injection..There is possibility of getting the ambiguity probelm if multiple depdendenices are found, but it doesn't throw the exception if the target class 0-param constructor otherwise the exception will be thrown..

<bean id="travelAgent" class="com.nt.beans.TravelAgent" autowire="constructor"> First it tries to do the byName type autowiring otherwise it looks for the byType..

public void setTourPlan(TourPlan tourPlan) {		For the autowiring using the byName the Bean Should match the tourPlan
		System.out.println("Travel Agent setTourPlan()");
		this.tourPlan = tourPlan;
	}
					AutoWire By Constructor
public TravelAgent(TourPlan plan) {   **The beanName should map to the varaible name.. Then it perfoms the ByName mode of Injection
		System.out.println("Travel Agent 1 Param Constructor");
		this.tourPlan=plan;	** If the names doesn't match then it tries to perfom the byType.If multiple dependencies found and zero param 
	}				constructor is found.. It just creates the empty object without throwing the exception.If zero param constructor is 
					also not found then it throws NoUniqueBeanDefFound Exception..


	<bean id="travelAgent" class="com.nt.beans.TravelAgent" autowire="constructor">
		  <!-- <property name="tourPlan"  ref="tourPlan"/>  -->
	</bean>
 	<bean id="tourPlan" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir</value>
 			<value>Araku</value>
 		</array>
 		</property>
 	</bean>
 	
 	<bean id="tourPlan1" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir1</value>
 			<value>Araku1</value>
 		</array>
 		</property>
 	</bean>

------------------------------------------------------------------------------------------------------------------------------------------------------------

What happen if targetclass is having the  multiple constructors..And we are depending on the constructor mode of injection

public TravelAgent() {
		System.out.println("Zero Param constructor Tourplan");
	}
	 
	public TravelAgent(TourPlan tourPlan) {
		System.out.println("Travel Agent 1 Param Constructor");
		this.tourPlan=tourPlan;
	}
		Look forbyName if no byType   Look forbyName if no byType
	public TravelAgent(TourPlan tourPlan,TourPlan tourPlan1) {
		System.out.println("Travel Agent 2 Param Constructor");		It always does the constrcutor injection on the hghest constructors
		this.tourPlan=tourPlan;
		this.tourPlan1=tourPlan1;
	}

Lets say we have only one tourPlan.. Then first constructor-arg type is byName and second constr-arg type is (byName not satisfied it looks for the byType)
satisfied so it injects that object into the TargetClass

bean id="tourPlan" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir</value>
 			<value>Araku</value>
 		</array>
 		</property>
 	</bean>
 	

autowire="autodetect":
---------------------

Autowiring by autodetect uses two modes, i.e.constructor or byType modes. First, it will look for valid constructor with arguments. If it is found, then the constructor mode is chosen. If there is no constructor defined in a bean, the autowire byType mode is chosen... Removed from spring 3.0 onwards..

autowire="no" Disables the autowiring

What happens if we enable the both autowiring and explicit wiring on the same bean property?

if both wirings are perfoming in the same constructor injection or the same setter injection then the explicit wiring value will be injected as the final values..if both the wirings are perfoming two different types of injections then the setter injection values will injected as the final value..

Can we apply the @AutoWired annotation on the multiple constructors?

							Dependency Check-:
							------------------

while perfoming the constructor injection by using the certain parameterized constructor,all the params for the constructor need to be configured for wiring
if not configured then exception will be thrown

The above restriction is not there for the setter injection configuration..to enable such restriction while working with setter injection go for the depdency-check attribute in the bean tag..

dependency-check="simple" dependency-check="objects" dependency-check="all" dependency-check="none"


Note: dependency-check is removed from the Spring 2.5 because it applies the resttriction on the group of properties not on the specified properties..
Required is given as the alternative..


Nested Bean Factory:
--------------------

In realtime project contains multiple layers..instead of configuring all the beans inside one IOC container it is recommended to take multiple IOC containers on one per layer basis...To use the beans of one IOC conatiner inside the another IOC container it is recommended to make them as the Nested IOC conatiners like the parent & child containers..

The beans of the parent container can be used in the child container but the reverse is not possibel.. In the parent container we configure the persistence layer beans so it can be used in the child container where usually service layer beans are configured...

While working with nested bean factory SpringBean file associated with the Child container is called as the ChildConfiguration file and config-file associated with the parent conatiner is called as the Parent configuration file

Can you explain various attributes of the Spring <ref> tag?

<ref local="beanid"/> locates the bean id based Spring Bean configuration from the current/local spring beans configuration file..

<ref parent="beanid"/> locates the bean id based Spring Bean configuration from the parent Spring bean Configuration file...

<ref bean="beanId"/> First looks in the current/local/Child Configuration file if not found then it looks in the Parent Configuration file..

<property name="details">
	<ref bean="id"/>
</property>

	(OR)

<constructor-arg name="details">
	<ref bean="id"/>
<constructor-arg>

<property name="details" ref=""> is equals to the  <property name="details"><ref bean="id"/></property>


Parent Configuration file:

<bean id="loanDetails" class="com.nt.beans.LoanDetails">
	<property name="loanId" value="1234"></property>
	<property name="loanType" value="BankLoan"></property>
	<property name="customer" value="Muni"></property>
</bean>
	

Child Configuration file:

<bean id="approver" class="com.nt.beans.BankLoanApprover">
	<!-- <property name="details">
	<ref parent="loanDetails"/> These configuation is not working why? Need to check
	</property> -->
	<property name="details" ref="loanDetails"/>
</bean>


		///IOCProj24-NestedBeanFactory/src/main/java/com/cfg/loan-beans.xml
		BeanFactory pfactory=new XmlBeanFactory(
				new FileSystemResource("src/main/java/com/cfg/loan-beans.xml"));
		BeanFactory cfactory=new XmlBeanFactory(
				new FileSystemResource("src/main/java/com/cfg/approval-beans.xml"),pfactory);
		
		BankLoanApprover approver = cfactory.getBean("approver", BankLoanApprover.class);
		
		System.out.println(approver);

		DefaultListableBeanFactory pfactory1 = new DefaultListableBeanFactory();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(pfactory1);
		reader.loadBeanDefinitions(new FileSystemResource("src/main/java/com/cfg/loan-beans.xml"));
		
		DefaultListableBeanFactory cfactory1 = new DefaultListableBeanFactory(pfactory1);
		XmlBeanDefinitionReader reader1 = new XmlBeanDefinitionReader(pfactory1);
		reader1.loadBeanDefinitions(new FileSystemResource("src/main/java/com/cfg/approval-beans.xml"));
		
		BankLoanApprover approver2 = cfactory1.getBean("approver", BankLoanApprover.class);
		
		System.out.println(approver2);
		//As we are creating the two different containers then the BankLoanApprover Object is created inside the 
		//both containers
		
		System.out.println(approver.hashCode()==approver2.hashCode());

-----------------------JDBC Sample Code----------------------------------------------------------------	
st=con.createStatement();
rst=st.executeQuery(""SELECT Query");
int rows=stmt.executeUpdate(sql);

ps=con.prepareStatement(INSERT_SQL);
int rows=ps.executeUpdate();

pstmt = con.prepareStatement(selectQuery);
rst = pstmt.executeQuery();

----------------------Copying the DTO's to VO's------------------------------------------------------------
		List<EmployeeVO> listDTO=new ArrayList<EmployeeVO>();
		listDTO=service.searchEmpsByDesg(desgs);		
		//copy listDTO to listVO
		listDTO.forEach(dto->{
			 EmployeeVO vo=new EmployeeVO();
			 vo.setSno(String.valueOf(dto.getSno()));		----->Sample Code for collections copying to the other collection
			 vo.setEno(String.valueOf(dto.getEno()));
			 vo.setEname(dto.getEname());				--->Here the dataTypes used in the DTO classes and types used int VO 
			 vo.setJob(dto.getJob());				   class is different so we are manually doing the work
			vo.setSalary(String.valueOf(dto.getSalary()));		   but it is not same with the BeanUtils class.....
			vo.setDeptno(String.valueOf(dto.getDeptno()));
			listVO.add(vo);
		});
		

List<EmployeeBO> listBO=dao.findEmpsByDesg(cond);
List<EmployeeDTO> listDTO=new ArrayList<EmployeeDTO>();
//Convert ListBO to  ListDTO							--->Easy Code(Enhanced For Loop)
		for(EmployeeBO bo:listBO){
			 EmployeeDTO dto=new EmployeeDTO();
			 BeanUtils.copyProperties(bo,dto);  Into the common properties data will be copied!! 
			 dto.setSno(listDTO.size()+1);	    Into the specific properties we need to do copy manually	
			 listDTO.add(dto);
		}


/*listBO.forEach(bo->{
			EmployeeDTO dto=new EmployeeDTO();
			BeanUtils.copyProperties(bo,dto);
			dto.setSno(listDTO.size()+1);
			listDTO.add(dto);
		});*/


Working with ApplicatioContext Container:
-----------------------------------------

Bean Factory container means its an IOC conatiner that is created by the BeanFactory Object

ApplicationContext container means its an IOC conatiner that is created by the ApplicationContext Object..

ApplicationContext Object is the Object of javaclass that implements the ApplicationContext(I):

There are 3 implementations:  FileSystemXmlApplicationContext  ClassPathXmlApplicationContext XmlWebApplicationContext

FileSystemXmlApplicationContext:
Creates the applicationContext Object by locating the springbean configuration file from the directories of Application

ClassPathXmlApplicationContext:
Creates the applicationContext Object by locating the springbean configuration file from the directories and jar files added to the classpath of Application

XmlWebApplicationContext:
Creates the applicationContext container Object inside the WebApplications..

ApplicationContextContainer can perfom all the operations of the BeanFactoryContainer as well as the extra operations also:
----------------------------------------------------------------------------------------------------------------------------

1)PreInstallation of SpringBeans 2)Ability to work with Properties file 3)Support for the internatiolization 4)Support for event handling/processing etc..

While working with BeanFcatory container the container instantiates the beans(of any scope singleton/prototype) only when the factory.getBean() method is called but when the ApplicationContext conatiner is used all the singletonscoped beans will be pre-instantiated that means at moment when the conatiner is started.. This is called the pre-instantiation of the singleton beans..

If the prototype scoped bean is the dependent to the singleton scoped bean then the prototype scoped bean will also be pre-instatiated to support the dependency injection on the singleton scoped bean..but it doesn't mean the prototype scoped bean has changed it's behaviour changed to singleton****

Bean-Preinstantiaon is much similar to the <load-on-startup> on servlet..

JDBC datasource object represents the jdbc managed connection pool..we can use the jdbc datasource object to get connection object from the jdbc connection pool..DriverManagerDataSource gives the datasource object pointing to the IOC container managed jdbc connection pool.


Nested Application Context Example: Using multiple containers for multiple Layers:
---------------------------------------------------------------------------------
ApplicationContext pContext = 
			new ClassPathXmlApplicationContext("com/cfg/business-beans.xml");
	
ApplicationContext cContext = 
			new ClassPathXmlApplicationContext(new String[]{"com/nt/cfgs/presentation-beans.xml"},pContext);
		
EmployeeSearchController controller = cContext.getBean("empController", EmployeeSearchController.class);

Pre-instantion on the beans can be disabled using the lazy-int attribute in the bean tag:
-----------------------------------------------------------------------------------------
<!-- Dependent Beans -->
  <bean id="dtdc"  class="com.nt.beans.DTDC" scope="prototype"/>
  <bean id="bDart"  class="com.nt.beans.BlueDart"  lazy-init="true"/>
  <bean id="fFlight"  class="com.nt.beans.FirstFlight" scope="singleton" lazy-init="true"/>
  
  <!-- Main Bean/Target Bean -->
  <bean id="fpkt"  class="com.nt.beans.Flipkart" lazy-init="true"> If it is not set to true then all dependent Beans Objects will be pre-created
     <property name="courier"  ref="fFlight"/>
  </bean>


Working with Properties file:
-----------------------------

The javabean whose object holds the data required for the persistence logic or data generated by the persistence logic is called as the BO logic..

The text file that maintains the entries as the key value pairs is called as the Properties file..We generally use the properties file to mainatain the jdbc 
properties like DriverClassName,URL,USERNAME,PASSWORD and make them flexible to modify without touching the source code..

If the SpringF/W is added to the existing application and if existing project are using the properties file to get the data from the properties file to get the jdbc data then SpringF/w should be capable to fetch the data from the properties file..

The text file that maintains the entries as the key value pairs is called Properties file.. In ApplicationContext container environment we need to configure the PropertyPlaceHolderConfigurer class as the SpringBean to make the container to locate the properties file and recognize the place holders in SpringBean configuration file.. Place holders should be in the format that will be understandable by the Spring..

PlaceHolder: ${}.. Each PlaceHolder represents the 1 key of the property file to get the value from the properties file..

Need to configure the special Spring Bean to work with the properties files:Only ApplicationContext has capability to recognise this spring bean

 <bean
	class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations">
		<list>
			<value>com/nt/commons/jdbc1.properties</value>
			<value>com/nt/commons/jdbc.properties</value>
		</list>
	</property>
</bean>

Need to take the placeHolders inside the spring bean configuration file.. PropertyPlaceholderConfigurer loads properties from the properties files that are configured & then replaces the placeholders before the springbean configuration file is read from the ApplicationContext container...

<bean id="drds"   class="org.springframework.jdbc.datasource.DriverManagerDataSource">
     <property name="driverClassName" value="${jdbc.driver}"/>
     <property name="url" value="${jdbc.url}"/>
     <property name="username" value="${jdbc.user}"/>
     <property name="password" value="${jdbc.pwd}"/>
 </bean>


		pCtx=new ClassPathXmlApplicationContext("com/cfg/business-beans.xml");
		cCtx=new ClassPathXmlApplicationContext(new String[]{"com/cfg/presentation-beans.xml"},pCtx);
		//get Bean (Controller)
		controller=cCtx.getBean("empController",EmployeeSearchController.class);

No extra configurations required for the ApplicationContext container.. the PropertyPlaceHolder bean is automatically recognised..

For the XMLBeanFactory we need to configure the PropertyPlaceHolderConfigurer..

		XmlBeanFactory pfactory = new XmlBeanFactory(new ClassPathResource("com/cfg/business-beans.xml"));
		BeanFactoryPostProcessor bfpp = pfactory.getBean("ppc",PropertyPlaceholderConfigurer.class);
		bfpp.postProcessBeanFactory((ConfigurableListableBeanFactory)pfactory);
		
		XmlBeanFactory cfactory=new XmlBeanFactory(new ClassPathResource("com/cfg/presentation-beans.xml"),pfactory);
		controller=cfactory.getBean("empController",EmployeeSearchController.class);


Core Java Internatilization:
---------------------------

Locale Means (Country+Language)::

en-us en-Br fr-FR hi-IN(English as it is spoken in the Britan)

Making our application working for the different locales is called as the enabling the Internationalzation..It deals with displaying the Presentation labels

displaying the numbers.. In JEE application we work with ResourceBundle, LocalClass of java.util package to work with the I18N..

To apply the I18N we need to take the multiple properties file having the presentation labels on 1 per locale basis.. All these files must have the same keys & different values..

Eg:: app.properties(Base File) app_de_DE.properties(German) etc..

If no matching file is found the base file will be automatically used..

We can use the GoogleTranslator labels in other language based on the given English word..We can also place the Unicode numbers in properties file to render the non english characters..For that we need to use the third party tools like Unicode editor and jdk native2ascii tool

Use the website:https://r12a.github.io/app-conversion/..Copy the Hindicharacters(from Google Translator) (or) Spanish Words(from Tanslators) and convert into the Unicode characters.. and need to place them in the properties file against the value..save the file by taking the "unicode" as encoding type..

Use the JDK tool native2Ascii to get the unicode numbers... native2Ascii -encoding unicode inputfile outputfile..

native2ascii -encoding unicode C:\Users\91970\Desktop\Bangla.txt C:\Users\91970\Desktop\output.txt

In the webapplication if multiple servlet/jsp programs wants to display the Labels collected from the properties file then we need to create the ResourceBunlde class Object in the multiple servelt & jsp programms or we need to place the ResourceBundle class object inthe request scope as attribute

If we want to display the values of same key belonging to multiple locale properties files then we need to create the multiple ResourceBundle Objects..

ResourceBundle Object per Locale/properties file..We can overcome the problem in Spring environment by using the Application Context Container with the support of the ResourceBundleMessageSource class.. 

I18N:
----

Only ApplicationContext container supports the I18N.We can use the ResourceBundleMessageSource class as the spring bean by specifying the base property file name as the value of "baseName" property.

Since we configure the above class as the singleton scope SpringBean then that container will create one object and uses it for multiple times..But the above bean must be configured with fixed beanId "messageSource".. We can call the getMessage() to make the container to locate the proerties file based on the locale Object data that we pass with support of bean confgured with Beanid "messageSource".

Advantage: Just by using the One ResourceBundleMessageSource Object we can use the properties file in multiple locations..Allows to read the same message in different languages with one object of the above class..

		Locale locale=new Locale(args[0], args[1]);
		
		ResourceBundle bundle = ResourceBundle.getBundle("com/nt/commons/App",locale);
		
		System.out.println(bundle.getString("btn1.cap"));
		System.out.println(bundle.getString("btn2.cap"));
		System.out.println(bundle.getString("btn3.cap"));
		System.out.println(bundle.getString("btn4.cap"));


SpringAPP:

 <!-- ResourceBundleMessageSource class  cfg as spring bean having fixed bean id -->
    <bean id="messageSource"   class="org.springframework.context.support.ResourceBundleMessageSource">
         <property name="basename"  value="com/nt/commons/App"/>
    </bean>
    <!-- We are working with multiple properties file so not required to worry about configuration of the
    	 PropertyPlaceHolderConfigurer ResourceBundleMessageSource takes care-->
		
		ctx=new FileSystemXmlApplicationContext("src\\main\\java\\com\\cfg\\applicationContext.xml");
		//prepare Locale object
		locale=new  Locale(args[0],args[1]); //args[0] ->language  , args[1] -> country
		//get Messages
		cap1=ctx.getMessage("btn1.cap", new String[] {"student"} ,"msg1", locale);
		cap2=ctx.getMessage("btn2.cap", null, "msg2",locale);
		cap3=ctx.getMessage("btn3.cap", null, "msg3",locale);
		cap4=ctx.getMessage("btn4.cap", null,"msg4", locale);
		System.out.println(cap1+"   "+cap2+"   "+cap3+"   "+cap4);
		System.out.println(ctx.getMessage("btn2.cap", new String[] {" message"," Test"}, new Locale("de","DE"))); prints://aktualisieren message Tst
		System.out.println(ctx.getMessage("btn2.cap", null, new Locale("hi","IN")));
		System.out.println(ctx.getMessage("btn2.cap", null, new Locale("x","y")));

FallBackProperties File:
-----------------------
btn1.cap=insert
btn2.cap=update
btn3.cap=delete
btn4.cap=view

App_de_DE.properties:
---------------------

btn1.cap=einfgen{0}
btn2.cap=aktualisieren{0}{1}
btn3.cap=lschen
btn4.cap=Aussicht

Event Handling:
---------------
Event is the Object/action that is raised on the component/Object..Event Handling means executing the logic when the event is raised for this we need the support of EventListeners..

There are four actors in the event processing/Handling:
------------------------------------------------------

Source Object(Button) EventClass(ActionEvent) EventListener(ActionListener) EventHandling Method ( actionPerfomance(--))

We can perfom eventHandling on ApplicationContext container to keep track of when the container is created/started  or Stopped.This allows programmer to evaluate the perfomance of Spring code/logic

Source Object: ApplicationContext EventClass: ApplicationEvent ListenerClass: ApplicationListener EventHandling Method:onApplicationEvent() executes when the applicationContainer is started or stopped

Example App: Create the Class for event Handling implementing the ApplicationListener..Configure the Listener as the SpringBean.. Create the ApplicationContextContainer and stop the container inside the Java Application

<bean class="com.nt.listener.IOCContainerMonitoringListener"/>

public class IOCContainerMonitoringListener implements ApplicationListener<ApplicationEvent> {
     private long start,end;
     
     public IOCContainerMonitoringListener() {
		System.out.println("Listener:: 0-param constructor");
	}
     
	@Override
	public void onApplicationEvent(ApplicationEvent e) {
		if(e.toString().indexOf("ContextRefreshed")!=-1) {
			start=System.currentTimeMillis();
			System.out.println("IOC contaier is started at::"+new Date());
		}
		else if(e.toString().indexOf("ContextClosed")!=-1) {
			end=System.currentTimeMillis();
			System.out.println("IOC contaier is stopped/closed at::"+new Date());
			System.out.println("IOC container active duration ::"+(end-start)+" ms");
		}

	}
}


When to use the BeanFactory & Application Context Containers:?

If we are developing the small applications or embedded system applications having the support of the Spring then use the BeanFactory(Here few extra kb also matters..)If we are developing the enterprise applications(like distributed or web applications) then ApplicationContext is Prefrabble..


Operation of Container 						Bean Factory				ApplicatonContext

Bean Instantiation							yes					yes
Bean Wiring								yes					yes
AutoWiring								yes					yes
Properties file support							no					yes
I18N									no					yes
EventHandling								no					yes
Automatic Registration BeanPostProcessor				no					yes
Automatic Registration BeanPreProcessor					no					yes
Stopping/Closing Container 						no					yes

Spring Bean LifeCycle:
--------------------

It talks about the Springbean class Object creation to destruction..In the servlet life cycle we use the following lifecycle methods..

int() service() destroy()

in ordinary classes we use the constructor finalize methods to place the intialization and unintialization logics..

Springbean allows to lifecycle methods..

init() Method: Executes after all dependencies are injected.. so can be used to verify whether injection are done properly or not with appropriate value

Destroy() Method: Executes when the IOC container is about to destroy the bean class Object.. Useful to place the unintialization logics..

In Spring we can perfom the Spring LifeCycle operations in 3 ways:
----------------------------------------------------------------

1) Declrative Approach 2) Programmatic Approach  3) Annotation Approach

Declrative: Allows to configure the user defined methods as the bean lifecyle methods..These methods are called custominit or customdestroy methods..These methods return type should be void and shouldn't contain the parameters..

We must configure the above methods as the LifeCycle methods using the init-method and destroy-method attributes of the <bean> tag

<bean id="cve"  class="com.nt.beans.CheckVotingElgibility"  init-method="myInit"  destroy-method="myDestroy" >
     <property name="name"  value="raja"/> 
    <property name="age"  value="20"/>
    <property name="addrs"  value="hyd"/>


	factory=new DefaultListableBeanFactory();
	reader=new XmlBeanDefinitionReader(factory);
	reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
	//get Bean
	voting=factory.getBean("cve",CheckVotingElgibility.class);
	//invoke b.method
	System.out.println(voting.checkVotingElgibility());
	//factory.destroySingletons();
	factory.destroySingleton("cve");

Using the ApplicationContextContainer we can close the container or stop the container

		ctx=new ClassPathXmlApplicationContext("com/cfg/applicationContext.xml");
		//get Bean
		voting=ctx.getBean("cve",CheckVotingElgibility.class);
		//invoke b.method
		System.out.println(voting.checkVotingElgibility());

		//close container
		//((AbstractApplicationContext) ctx).close();
		((AbstractApplicationContext) ctx).stop();
		voting1=ctx.getBean("cve",CheckVotingElgibility.class); throws: illegstateException if we uncomment close method..with stop method we don't 										get
	       System.out.println(voting.hashCode()+" "+voting1.hashCode());


In the customInit methods we don't write the intialization logic because it won't execute after Bean INstantiation it executes after completing all the injections..While working with ApplicationContext conatiner we close the container by calling the close method..The container destroys all the bean classes Objects when this tasks is about to happen customdestroy/destroy method will be called.While working with BeanFactory container we can use the factory.destroySingletons() method to destroy all the singleton scoped beans..

Limitations of declarative Approach:
-------------------------------------

If you forget to configure the lifecycle method in xml file they will not be executed..Identifying the lifecycle method is complex while dealing with predefined or thirdparty supplied classes as the Spring beans..

In programatic approach Springbean class must implement IntializationBean or DisposableBean(I) given by the Spring API(Bean classes becomes API dependent)

@Override
public void afterPropertiesSet() throws Exception {} Alternative to customInit method..

@Override
public void destroy() throws Exception {} Alternative to the destroy method..

If we configure the both the Declrative and programmatic approach:Execution order

CVE:afterPropertiesSet(-) method
CVE:myInit()
CVE:checkVotingElgibility()
Mr/Miss/Mrs.raja u r elgible for voting
CVE:destroy()
CVE:myDestroy()

Recommended to use only one approach..Programmatic approach makes our Spring bean classes as the Spring API dependent.. Most of the Spring supplied classes are given based on the programmatic approach of bean life cycle.

Bean LifeCycle Annotation Approach:
----------------------------------

When we annotate a method in Spring Bean with @PostConstruct annotation, it gets executed after the spring bean is initialized.

We can have only one method annotated with @PostConstruct annotation. This annotation is part of Common Annotations API and its part of JDK module javax.annotation-api. So if you are using this annotation in Java 9 or above, you will have to explicitly add this jar to your project. If you are using maven, then below dependency should be added to it.

<dependency>
	<groupId>javax.annotation</groupId>
	<artifactId>javax.annotation-api</artifactId>  @PreConstruct & @PostDestroy Annotation's
	<version>1.3.2</version>
</dependency>


When we annotate a Spring Bean method with PreDestroy annotation, it gets called when bean instance is getting removed from the context. This is a very important point to understand  if your spring bean scope is prototype then its not completely managed by the spring container and PreDestroy method wont get called.

If there is a method named shutdown or close then spring container will try to automatically configure them as callback methods when bean is being destroyed.

Example::

		<dependency>
			<groupId>javax.inject</groupId>			Annotations like @Named will come
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>


<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd 
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context.xsd">
    
 	<!-- Bean defined and dependents are defined using the Annotations -->

	<context:component-scan base-package="com.nt.beans"></context:component-scan>  BeanFactory/DefaultListableBeanFactory cannot recognise this..
</beans>

@Named("cve")
@Scope("singleton")
public class CheckVotingElgibility{
	
	@Value("Muneendar")
	private String name;
	
	@Value("Hyderabadi")
	private String addrs;
	
	@Value("20")
	private int age;
	
	public CheckVotingElgibility() {
		System.out.println("CVE:0-param constructor");
	}

@PostConstruct
	public void myInit(){
		System.out.println("CVE:myInit()");
		if(name==null || age<=0)
			throw new IllegalArgumentException("provide valid inputs");
	}

@PreDestroy
	public void myDestroy(){
		System.out.println("CVE:myDestroy()");
		name=null;
		age=0;
		addrs=null;
	}


						Aware Injection/Interface Injection/Contextual Depedency Lookup:
						--------------------------------------------------------------
If the underlying container assigns or injects the values or objects to target class only when it implements/extends certain interface/class is called as the contextual dependency lookup..

Ex:ServletContainer assigns the config object to our servlet class only when the servlet class implements the javax.servlet.Servlet directly or indirectly...


If one class needs the another class then we go for the depedencylookup/dependencyinjection..If target class wnats to use the dependent object in all the methods of the target class then we should go for the dependency injection..If target class wants to use the dependent object only in the specific methods then we should go for the dependency lookup..

If we perfom the dependency lookup in the regular fashion we need to create the one more IOC container in the target class to get the Dependent object..
so instead of creating the seprate IOC container to inject the BeanFactory/Application Context object by implementing the BeanFactoryAware...The underlying container is injecting the Object/value only when the target class implements the XXXAware interface. So it is called the AwareInjection/Interface injection
or contextual dependency lookup..

XXXAware Interfaces are::

BeanNameAware --->To inject the current beanid
BeanFactoryAware-->To inject the BeanFactory Object
ApplicationContextAware-->To inject the ApplicationContext Object


The IOC conatiner created by the BeanFactoryObject  internally maintains the beanId's..The IOC conatiner created by the ApplicationContextObject  internally maintains beanId's ApplicationContext Object BeanFactoryObject etc..

public class Viechle implements ApplicationContextAware {
	
	private String beanId;
	private ApplicationContext ctx;
	
	static{
		System.out.println("Viechle:static block");
	}
	
	public Viechle() {
		System.out.println("Viechle:0-param constructor");
	}

	public void setBeanId(String beanId) {
		System.out.println("setBeanId(-)");
		this.beanId = beanId;
	}
	
	@Override
	public void setApplicationContext(ApplicationContext ctx) throws BeansException {
		System.out.println("setApplicationContext(-)");
		this.ctx=ctx;
	}
}


ApplicationContext ctx=new ClassPathXmlApplicationContext("com/cfg/applicationContext.xml"); As soon as the ApplicationContext Object is created then the Vechicle class Objected is craeted and ApplicationContext Object is injected into the class..

Viechle:static block
Viechle:0-param constructor
setBeanId(-)
setApplicationContext(-)


Problem with LookUp Method Injection:
------------------------------------
<bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton">
       <property name="handler"  ref="rh"/>
   </bean>

When the protoType scoped bean is dependent to the Singleton scoped bean then somehow prototype scoped bean also acts as the SingletonScoped Bean..

Eg: All requests coming to the WebApplications will be handled by the Single ServletContainer/WebContainer..This container should be using the seprate request handler to process each request..So, Servlet Container is target class and RequestHandler should be taken as the dependent class and moreover the servlet container should be taken as the Singleton scoped bean and request handler should be taken as the prototype scoped bean..But because of above problem "RequestHandler" also acts as the Singleton Scoped bean 

TargetClass Bean Scope                 DependentClass Bean Scope      ResultantScope of DependantBean
----------------------------------------------------------------------------------------------------------
Prototype				Singleton			Singleton

Singleton				Singleton			Singleton

Prototype				Prototype			Prototype

Singleton				Prototype			Singleton(Use the dependency lookup or LookUp Method)


We Shouldn't think of dependency injection(constructor/setter) in the following situations:

If the dependent bean is required for the Target BEan only in the specific methods if the target bean scope is singleton and dependent bean scope is prototype in the above situation we should prefer for the dependencyLookup.If we go for the traditonal depdency lookup we should go for the extra IOC container in the methods of the target class.(Which is Bad Practisce).. By using the Aware Injection we can avoid the extra IOC container in the above methods of the Target class..But it kills the NonInvasive behaviour of the Spring APP because the target bean should implement xxxAware injection


To overcome the above two problems we can use the dependency Lookup method Injection which "perfoms the dependency lookup" but container should write the code for it(not the programmer)

To perfom the Lookup method Injection the in TargetClass we should consider the below points:
--------------------------------------------------------------------------------------------

Target Bean class should have the abstracted method returining the dependant bean class Object(For this target class should be taken as Abstract C/Interface 

We must configure the above abstract methods with targetBean class by using the <lookup-method> tag..

Note:: We can configure the abstract class as the Spring Bean only when the <lookup-method> tag is placed for lookup method injection otherwise not possible

Spring IOC container generates the subclass for the targetBean class & implements the abstract method that class to get & return the dependent bean class Object.. For this it internally uses the CGLIB. In Spring 2.x 3.x we need to separately supply CGLIB where as in Spring 4.x not required..

Lookup Method Injection(Usecase):

ServletContainer(Singleton)<----------------->RequestHandler(ProtoType)
Manager(Singleton)<----------------------------->Customer(ProtoType)
LoanApprover(Singleton)<------------------------>LoanDetails(Prototype)

Lookup Method Injection Solutions: Using the Tradiotional Lookup Operation.. Using the AwareInjection+DL...

LMIFinalSolution

<bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton" >
      <lookup-method name="getRequestHandler" bean="rh" /> 
   </bean>

public abstract class WebContainer {
	
	public abstract RequestHandler getRequestHandler();
	
	public WebContainer() {
		System.out.println("WebContainer :: 0-param constructor");
	}
	
	public void  delegateRequest(String data){
		RequestHandler handler=null;
		System.out.println("WebContianer: request recived with "+data+" and delegating to handler");
		//create IOC container
		//get Depedent Bean obj
		handler=getRequestHandler();
		handler.proessingRequest(data);
	}
	
}//class



Using the Java8 the Target Class can also be the interface:
------------------------------------------------------------

public interface WebContainer {
	
	public  RequestHandler getRequestHandler();

//Only one implementation class is created but this method is called onDemand whenever this bean is needed and new
//Object is returned always
	
	default void  delegateRequest(String data){
		RequestHandler handler=null;
		System.out.println("WebContianer: request recived with "+data+" adn delegating to handler");
		//create IOC container
		//get Depedent Bean obj
		handler=getRequestHandler();
		handler.proessingRequest(data);
	}
	
}//class


 <bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton" >
      <lookup-method name="getRequestHandler" bean="rh" /> 
   </bean>


FactoryBean:
----------

The class that is capable of creating and returing Objects is called Factory Class..In Spring FactoryBean is selfless bean it doesn't give its own object, but it always give one resultant object..

To develop class as the FcatoryBean Class must implement SpringAPI's FactoryBean(I) and should provide definition for the Three methods:

getObject() -->creates and returns resultant Object 
getObjectType()--->returns java.lang.Class object holding the resultant Object class name
IsSingleton()--->Specifies whether resultant Object should be taken as singleton Object(true) or prototype Object(false)


The bean that gets Objects from the JNDIRegistry based on given JNDI name will be developed as the FactoryBean

Factory using the ServiceLocator: instancefactory staticFactory method FactoryBean implementation.. 

MethodReplacement:
-------------------
In the normal classes if you want to replace the existing logic of business method with new logics we have 2 options:

1) Comment the existing logics and write the new business logic in the Same business method
2) Devlop the subclass and override the business method with the new logics..

In the above model we need to modify the source code to revert back to the original logics if we write new logics on expermental basis or the new logics execution has failed in the production environment at the client side..The another problem with the above approach is reverting back to the original logics is comlaex when the source code is not exposed...

To excute the new logic when the offer period is there and revert back to the orginal logics once the offer is over without touching the source code we can't use the above models..

To overcome the above problem we use the "MethodReplacemet" concept of Spring..For this we need to develop the seprate Class implementing the MethodReplacer (I) and need to write the new logics inside the reImplement() method..

public Object reimplement(Object obj,Method method,Object[] args): 

Object obj: Gives the access to the original bean class obect.. Method method: gives the access to the orginal method that we wanted to replace.

Object[] args: Gives access to the orginal method args..


We need to configure the MethodReplacer class as the Spring Bean and we need the IOC conatiner to execute the reimplement() When the original method is called.  <replaced-method name="original method name" replacer="BeanId method replacer class"/>

When the ctx.getBean(-) is called then the container checks whether the <replaced-method> tag is configured or not in the inmemory metadata of xml file. If configured then container generates the inMemory proxy class and returns that Object..If not configured it creates the bean Class Object and retruns that Object..

public  class IntrAmountCalculator {
	
	public   float  calcSimpleIntrAmount(float pAmt,float time){
		
		System.out.println("IntrAmountCalculator::calcSimpleIntrAmount(-,-)");
        return (pAmt*2*time)/100.0f;
     }

	//public abstract  float  calcSimpleIntrAmount(float pAmt,float time);
}

<bean id="iac"  class="com.nt.beans.IntrAmountCalculator">
      <replaced-method name="calcSimpleIntrAmount"  replacer="csirmr">
         <arg-type >float</arg-type>
         <arg-type >float</arg-type>
      </replaced-method>
  </bean>
   
<bean id="csirmr"  class="com.nt.beans.CalcSimpleIntrAmountMethodReplacer">
       <constructor-arg  value="1.0"/>
   </bean>

public class CalcSimpleIntrAmountMethodReplacer implements MethodReplacer {
	private  float rate;
	
	 public CalcSimpleIntrAmountMethodReplacer(float rate) {
		this.rate = rate;
	}

	public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
		System.out.println("MethodReplacer::: reimplement(-,-,-)");
		  float pAmt=0.0f , time=0.0f;
		  pAmt=(Float)args[0];
		  time=(Float)args[1];
		  return (pAmt*rate*time)/100.0f;
	}
	
	 
}	 

**Important Points:
-------------------

1)The methods that you want to replace should not be the "final static"(This method can't be ovveriden in the subclass)

2) Even though you can't write the replacement logics for multiple methods in the single "reImplement()" by using the if conditions it is recommended to    take the separate method replacer class for the every method.


Internals:: IOC conatiner creates the subclass for the mainbean class Like Bank is Bank$$CGLIB.. By using the CGLib library internally.. In this class business method(cakcIntrAmt() ) will be oveeriden. In the method definiton the object of method replacer will be accessed and reImplement() will be called

Due to this new logic will be exeucted when the client calls the ctx.getBean() or factory.getBean() the above generated subclass object will be returned..


Various Injection:
-----------------

1) SetterInjection
2) Constructor Injection
3) Aware Injection/Contextual Dependency lookup/Interface Injection
4) Method Injection(Method replacer)
5) Lookup Method Injection


Bean Post Processor:
--------------------

Assigning some values to the bean properties after the injection is called post processing..We can do this post processing inside the bean class and specfic to bean class by using the custom init method or intializing Beans afterPropertiesSet() method..

If we want to apply the common post processing logic for multiple beans that to being from the outsisde of the bean class then we can use BeanPostProcessor

The beanPost processor executes for all the beans that are configured in the Spring Bean file.To develop the BeanPostProcessor we need to take a class that implements BeanPostProcessor and should provide the implementation for the 2 methods..

postProcessorBeforeIntialization(Obect bean,Spring beanId) Executes before the afterPropertiesSet() for the every bean class.

postProcessorAfterIntialization(Obect bean,Spring beanId) Executes after the custom init() for the every bean class configured inside the SpringBean File..

This concept is useful for developing the Custom postprocess/intialization logic common for all the beans in one class.

If we configure the BeanPostProcessor as the Spring bean then ApplicationContext can recognise.. But with BeanFactory we should do some extra configurations...

factory=new XmlBeanFactory(new ClassPathResource("com/nt/cfgs/applicationContext.xml"));	((ConfigurableListableBeanFactory)factory).addBeanPostProcessor(new PersonBOPostProcessor());


Bean PostProcessor gets applied for the Singleton and ProtoType beans also:
--------------------------------------------------------------------------

 <bean id="dao"  class="com.nt.dao.CollegeDAOImpl" scope="singleton"/>
  
  <bean id="stBO"  class="com.nt.bo.StudentBO"  scope="prototype"/>
  <bean id="empBO"  class="com.nt.bo.EmployeeBO" scope="prototype"/>
  
  <bean id="service"  class="com.nt.service.CollegeServiceImpl"   scope="singleton">
      <constructor-arg ref="dao"/>
      <lookup-method name="getStudentBO"  bean="stBO"/>
      <lookup-method name="getEmployeeBO"  bean="empBO"/>
  </bean>
  
   <bean id="pbbpp" class="com.nt.bpp.PersonBOPostProcessor"/>


Recognising the Annotations using the context:componentScan

In the realtime the BeanPostProcessor Will be used to place the common post process intialization logic that is required for the multiple beans assigning the systemdate as DOJ, or last modificationDate or dateofUpdation and etc.. This concept is useful towards the auditing activity

While working with ApplicationContextContainer if we just configure the BeanPostProcessor class in the xml file as SpringBean then container recognises and use that as the BeanPostProcessor..While working with BeanFactory we have to register BeanPostProcessor explicitly

//		factory=new XmlBeanFactory(new ClassPathResource("com/nt/cfg/applicationContext.xml"));	
//	    ((ConfigurableListableBeanFactory)factory).addBeanPostProcessor(new PersonBOPostProcessor());


Bean LifeCycle w.r.t to BeanFactoryContainer:
--------------------------------------------

Instiantiate

Populate Properties(Using the constructor/SetterInjection)

BeanNameAware's setBeanName()

BeanFactoryAware setBeanFactory()

PreIntialization() BeanPostProcessors

IntalizingBeans afterPropertiesSet()

Call the custom init() method

PostIntialization BeanPostProcessor
	|
	|
Bean is ready to use now
--------------------------------------------------------------------------------------
Container is Shutdown

Disposable Bean's destroy()

Call the custom destroy() method


**If the underlying container is ApplicationContext container it can inject both the BeanFactory ApplicationContext Objects to spring bean through the XXAwareInjections.If the bean class implements the factory-bean interface/factory-method attribute is configured in the bean tag then the container doesn't create the given bean class Object..

**Container creates/gets resultant object and keeps that resultant Object with configured bean Id.

	

Bean LifeCycle w.r.t to ApplicationContextContainer:
---------------------------------------------------

Instiantiate

Populate Properties(Using the constructor/SetterInjection)

BeanNameAware's setBeanName()

BeanFactoryAware setBeanFactory()

ApplicationContextAware's setApplicationContext()    *****

PreIntialization() BeanPostProcessors

IntalizingBeans afterPropertiesSet()

Call the custom init() method

PostIntialization BeanPostProcessor
	|
	|
Bean is ready to use now
--------------------------------------------------------------------------------------
Container is Shutdown

Disposable Bean's destroy()

Call the custom destroy() method


Complete Internal flow of the core module:
------------------------------------------

1) Programmer creates the BeanFactory Object 2) Given Spring bean configuration file will be located and it will be verified whether documents is well formed document or valid document.3) Creates the inmemeory logical IOC container in the jvm's memory.4)Reads the spring bean configuration file entries and 
creates an inmemory metadata having all the configuration.5) Client App calls factory.getBean("id") method..6) Loads the bean class from the inmemory meta data based on the given beanId and instantiates that bean based on the constructor injection configuration..
7)Keep the bean class Object in the specified scope..(If the cyclic dependency is configured then Bean Instantiation gets failed.)
8) Perfoms the setter injection based on configuration by perfoming the dependency-check
9)Perfoms the Aware Injections based on the AwareInterfaces that is implemented by the SpringBean
10)Calls the postProcessBeforeIntialization() if the beanPostProcessor is added..
11)Calls the afterPropertiesSet() if the IntializationBean(I) is added.
12)calls the custom init method if the "init-method" attribute is specified.
13)Calls the postProcessAfterIntialization()
14)Returns the bean Class Objects to the client application

***)If the ApplicationContext Object is created the steps(6-14) will be taken place automatically without calling the getBean() for the SingletonScopes...

***)If the <lookup-method> or<replaced-method> tag is configured insdie the <bean> tags container doesn't create the Object given BeanClass.. It creates the Object for the Subclass of the bean class which is generated by the IOC container..



BeanFactoryPostProcessors:
-------------------------

BeanPostProcessor is useful to write the postProcess Intialization logics with multiple Beans..BeanFactoryPostProcessors is useful to add the extra configurations by modifying the inmemory metadata after the creation of the IOC container and before the accessing the bean Object using the getBean()

It acts as the extension/hook for the IOC container to add the extra configuration without touching the xml file..It modifies the inmemory data of IOC container dynamically at runtime after the IOC container creation and before the bean class Object is accessed..To develop the Custom BeanFactoryPostprocessor we need to devleop the class implementing BeanFactoryPostprocessor(I).

Spring has lots of predefined BeanFatoryPostprocessor like PropertyPlaceHolderConfigurer.. This class modifies the inMemory meta data by replacing the placeholders ${} with the values created from properties file..

ApplicationContext Object based IOCcontainer automatically recognises BeanFactoryPostProcessor that is configured in the xml file, but for the BeanFactory Object based IOC container we need to register explicitly

By default we cannot work with properties file and PlaceHolder using the BeanFactoryContainer. But we can make it working by registering the PropertyPlaceHolderConfigurer as the beanFactoryPostProcessor

BeanFactory factory=new XmlBeanFactory(new FileSystemResource("applicationContext.xml"));

BeanFactoryPostProcessor bfpp=factory.getBean("PPC",PropertyPlaceHolderConfigurer.class);

bfpp.postProcessBeanFactory((ConfigurableListableBeanFactory)factory)


Property Editor:
---------------

In Spring we use the setter & consconstructor injection to assign the values to the bean properties. In Spring bean configuration file we configure those dependants values as the String values, but theyy will be converted to int,long,float,Date etc.. values as required for the bean properties automatically.

For this Spring internally uses the PropertyEditors to convert the String into the appropriate values..All the property Editors are the classes implementing from java.bean.PropertyEditor(I)..Builtin Property Editors:  StringArrayPropertyEditor ByteArrayPropertyEditor DateFormatPropertyEdior etc...

public class AadharDetails {
	
	private String name;
	private long uid;
	private char gender;
	private Date   dob;
	private float  age;
	private File  photoPath;
	private String[] verifiers;
	private  boolean isSingle;
	private URL  googleURL;

}


 <bean id="aadhar"  class="com.nt.beans.AadharDetails">
     <property name="name" value="raja"/>
     <property name="age" value="30"/>
     <property name="gender"  value="M"/>
     <property name="googleURL" value="https://google.co.in/search"/>
     <property name="uid" value="545454545455"/>
     <property name="dob" value="12-26-1990"/>
     <property name="photoPath" value="c:/abc/xyz/james.png"/>
     <property name="verifiers"  value="modi,amitSha"/>
     <property name="isSingle"  value="true"/>
</bean>


CustomPropertyEditor:
--------------------

public class LoanDetails {
	
	private float pAmt;
	private float rate;
	private float time;
}

public class BankIntrAmountCalculator {
	
	private LoanDetails  details;
}

<!-- <bean id="ld"  class="com.nt.beans.LoanDetails">
      <constructor-arg name="pAmt"  value="100000"/>
      <constructor-arg name="rate"  value="2"/>
      <constructor-arg name="time"  value="12"/>
  </bean> 
  
  
  <bean id="biac"  class="com.nt.beans.BankIntrAmountCalculator">
      <property name="details"  ref="ld"/>
    </bean>-->
   
   <bean id="biac"  class="com.nt.beans.BankIntrAmountCalculator">
      <property name="details"  value="100000,12,2"/>
    </bean>	


public class CustomLoanDetailsEditor extends PropertyEditorSupport {

	 @Override
	public void setAsText(String text) throws IllegalArgumentException {
		 float pAmt=0.0f,rate=0.0f,time=0.0f;
		 LoanDetails details=null;
		 //get values from property (text)
		 pAmt=Float.parseFloat(text.substring(0,text.indexOf(',')));
		 time=Float.parseFloat(text.substring(text.indexOf(',')+1, text.lastIndexOf(',')));
		 rate=Float.parseFloat(text.substring(text.lastIndexOf(',')+1, text.length()));
		 System.out.println(pAmt+"  "+time+"  "+rate);
		 //create LoanDetails class object
		 details=new LoanDetails(pAmt,time,rate);
		 //set value to Property
		 setValue(details);
	}
}

While working the BeanFactoryContainer or the DefaultListableBeanFactory we need to register the PropertyEditorRegistar Seprately
------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new XmlBeanFactory(new ClassPathResource("com/cfgs/applicationContext.xml"));
		   //add Custom PERegistart to IOC container
		 
		 ((ConfigurableListableBeanFactory)factory).addPropertyEditorRegistrar(new MyPERegistar());
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
	 }
	 
	 private static class MyPERegistar implements PropertyEditorRegistrar{

		@Override
		public void registerCustomEditors(PropertyEditorRegistry peRegistry) {
			 peRegistry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
		}//method
	 }//inner class
}//outer class

------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new DefaultListableBeanFactory();
		  reader=new XmlBeanDefinitionReader(factory);
		  reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		   //add Custom PERegistart to IOC container
		   factory.addPropertyEditorRegistrar(new PropertyEditorRegistrar(){

			@Override
			public void registerCustomEditors(PropertyEditorRegistry registry) {
				registry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
			}
		   }
		   );
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
	 }
------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new DefaultListableBeanFactory();
		  reader=new XmlBeanDefinitionReader(factory);
		  reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		   //add Custom PERegistart to IOC container
		  factory.addPropertyEditorRegistrar(registry->{
			  registry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
		  });
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());

------------------------------------------------------------------------------------------------------------------------------------------------------------
While working with the ApplicationContext context we just need to configure the CustomEditorConfigurer Bean in the applicationContext.xml:

    <bean id="cec"  class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
          <map>
             <entry key="com.nt.beans.LoanDetails" value="com.nt.editors.CustomLoanDetailsEditor"/>
          </map>
        </property>
    </bean>

 ApplicationContext ctx=null;		 
		 BankIntrAmountCalculator bank=null;
		 //create  IOC container
		  ctx=new ClassPathXmlApplicationContext("com/cfgs/applicationContext.xml");
		 //get Bean 
		 bank=ctx.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
		 
		 //close container
		 ((AbstractApplicationContext) ctx).close();

------------------------------------------------------------------------------------------------------------------------------------------------------------
 <bean id="cec"  class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
          <map>
             <entry key="com.nt.beans.LoanDetails" value="com.nt.editors.CustomLoanDetailsEditor"/>
          </map>
        </property>
    </bean>

factory=new DefaultListableBeanFactory();
reader=new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions("com/nt/cfgs/applicationContext.xml");
//Get CustomEditorConfigurer Bean(BFPP) & register
processor=factory.getBean("cec",BeanFactoryPostProcessor.class);
processor.postProcessBeanFactory(factory);

------------------------------------------------------------------------------------------------------------------------------------------------------------

					Spring Core Annotations:

Annotations: Data about the data and code about the code is called the MetaData..Annotations are java statements to perfom the metadata operations in the .java files.. Annotations are alternate for the xml files to perfom the metadata,resource configuration operations. XML files gives the bad perfomance because the xml parsers are heavy to process the xml documents..

Annotations donot provide flexibility of modification but provide the good perfomance..

Annotations for the documentation are from JDK 1.0..Annotations for the programming are introduced from the JDK 1.5. We can apply the annotations at the different level class level, Method level, field level and Param level..The annotations are used by the compilers containers AnnotationProcessors JRE etc..

Some annotations provide the instructions to compiler but no effect will be there at Runtime.. 
@author @Since etc.. @override tells the inherited methods of the classes/interfaces as special items..

Some annotations are useful to mark the classes/interfaces as the Special items..
@Entity makes the ordinary JavaBean as hibernate/domain class
@WebServlet --->Makes the class as the Servlet Component..

Some annotations are useful to generate new classes using the tools dynamically based on the given class code..Eg: @WebService

All the java technologies/frameworks designed after the jdk1.5 are supporting the Annotations.

*****If we override the certain settings using the Annotations and xml file settings done in xml file will override the settings done through Annotations...

Spring Annotations:
-------------------

Spring 2.0 onwards there is support for annotations and more annotations are added incrementally in the next versions..In Spring programming we can instruct the IOC container to recognise the annotations only through xml file..We cannot use annotations to make the Predefined classses as the Spring Beans..To confgure such classes we need to take the help of XML..

@Required: To make the dependency injection(setterinjection) mandatory on properties we can use the dependency check activity..But it is removed from Spring 2.5 because it doesn't allow the programmer to enable the restriction on the specific properties.. It allows the programmer to enable the restriction on the group of properties like "simple" "object" "all".. To overcome this probelm we can use @Required..


The BeanPostProcessor of every Annotation contains the logic to recognize the annotation and to provide the functionality for the annotation. But configuring the BeanPostprocessor of every annotation is the complex process.To overcome this problem we use the <context:annotation-config/> tag.
To work with this tag import the context schema namespace in the xml..


@Required is Deprecated from the Spring 5.x:
--------------------------------------------

While working with Application Context it is not required to configure the BeanPostProcessor of Annotation in the xml file..

***While working with the DefaultListableBeanFactory we need to register the BeanPostProcessor of Annotation explicitly..

  </bean>
    <bean id="requiredAnnconfig" class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/> 
   
   <context:annotation-config/>
   
while working with the <context:annotation-config/> tag we need to add the SpringAOP version jar into the buildpath..

factory=new DefaultListableBeanFactory();
reader=new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions("com/cfgs/applicationContext.xml");
//register BPP
//factory.addBeanPostProcessor(new RequiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(factory.getBean("requiredAnnconfig",BeanPostProcessor.class));
//get Bean
per=factory.getBean("per",Person.class)



@AutoWired: 

Given to perfom the byType byName and constructor mode of autowiring..This annotation can be applied at the Filed Level Setter method level,Constructor level and aribitary method level also

If the dependant bean is not available to perfom the dependency injection through autowiring the exception will be raised when the required is 
true.. The deafult value is true.. Null will be assigned if the required=false and dependant bean configuration is not available(No Exception is raised)

We cannot apply the AutoWired annotation on the top of the zero param constructor..At max only 1 constructor can have the @Autowired annotation...When the @Autowired annotation is placed on the top of the field or setter method or the aribtary method the byType mode of autowiring will takes place... When the same annotation is placed on the Constructor then constructor mode of autowiring will takes place..

@Qualifier:: While perfoming the byType mode of autowiring there is a possibility of getting the ambiguity if multiple depndant beans are found to inect into target class. Inorder to overcome this problem we need to use @Qualifier annotation which makes the IOC container to perfom the byName mode of autowiring


@Component @Service @Repository @Controller:
--------------------------------------------

The above annotations are called as the SteroType annotations, because all the 4 type of annotations are having the same purpose with the minor change..

We can use all the 4 annotations to configure the java classes as the Spring beans..

@Component: Generic purpose stero type annotation to configure any java classes as the Spring beans..Exposes the given java class as the Spring bean to IOC conatiner.

@Service:Specification of the @Component, useful to configure the java classes of the service layer..As of now no special behaviour so it is same as Component

@Repository:Specification of the @Component, useful to configure the dao classes of the Repository layer.Capable of translating the one form of excpetion to the another form of exception..

@Controller:Specification of the @Component, useful to configure the classes as the controller of the Spring mvc app to process the request given by the clients..

<context:component-scan base-package="com.nt.beans"/> To identify the Spring beans that are annotated with the above annotations..
<context:annotation-config/> If you configure the <context:component-scan/> not required to configure <context:annotation-config/> all anotations benPostProcessors will be automatically configured..


Java Config Annotations: If you the @Component @Autowired etc.. are the Spring supplied annotations, if we use this annotations of the code of spring bean becomes tightly coupled code to the Spring Framework..This kills the non invasive feature of the Spring f/w.For overcoming these problem we use the java config annotations given by the JSE and JEE module..For these annotations functiaonality will be given by the container and frameworks that we are using..

For exmple for @inject spring provides its functionality and EJB also provides its functionality so when we change the F/w we can still depend on the same Annotations.. These annotations are provided as part of J2SE and JEE specifications but the implementation will be provided by the different servers and frameworks.. If we change the Runtime libraries of App we can still use the same annotations inside the classes.


@Inject: It is given inside the JEE specification inside the javx.inject package having the ability to perfom byname,bytype/constructor mode of autowiring..

Equal to @Autowired but the difference is there is no Required Parameter..

@Inject is java config anntation so Spring APP becomes the Non Invasive Framework..


@Inject can be applied at the field level method(setter/orbitory) or the constructor level.. To work with @Inject & @Named kind of JavaConfig annotations we need to add the javax.inject.jar files.. Total Jar Files:: IOCLib+SpringAOP.jar+javax.inject.jar


@Named:: It is the Java Config annotation of 'javax.inject' package of Jee specification..This anotation can be used in the two ways:

1)To resolve the ambiguity problem that is raised while perfoming the byType mode of autowiring..It is alternate to @Qualifier can be used along with the @Inject @Resource @Autowired..

2)To configure or mark the java classes as the Spring beans as alternate to the Spring specific annotations like @Component etcc....

@Resource: It is the JDk supplied Annotation of javax.annotation package.. Can be used to perfom the byType,byName mode of Autowiring.. Can be applied at the filed, method(setter/orbitory method) level.. By using the param attribute of annotation we can perfom the byName mode of autowiring..


****Note:: Ambiguity problem cannot be handled by the @Named Annotation instead you can use the @Qualifier or the @Resource Annotation

/**@Named cannot handle if there are multiple beans*/
	
//@Inject @Named("engine") private Engine engg;


Differences between the @Autowired @Inject @Resource::
-----------------------------------------------------

@Autowired 					@Inject						@Resource

Spring Annotation				JEE javaConfig					JavaConfig Annotation

Supports byType,byName				Supports byType,byName				Supports byType and byName
Constructor mode of Wiring			Constructor mode of Wiring

Makes Spring Bean class as			Non INvasive					Non INvasive
Invasive

Param Required is available			Non_Param					Param name is available

AmbiguityProblem:@Qualifer use			@Named @Qualifier can be used			We can use the @Named or name param available to resolve


Java Config Annotations for configuring the BeanLifeCycle Configurations: @PostConstruct & @PreDestroy
------------------------------------------------------------------------

to configure the normal methods as custom destroy/init methods both methods should have the following signature:

public void <method>(){}

@Scope:: Spring Annotation which can be applied on the class to specify the SpringBean scope


Working with Properties file in the Annotation Environment:
----------------------------------------------------------

To detect the classes and recognise the them as Spring beans through Annotations we can use the <context:component-scan> tag.

To detect the specified properties file that is configured through Annotation we can use <context:property-placeholder> tag..To inject the values of the properties file to bean properties we need to specify the keys of properties file through placeHolder ${key}..

@Named("dao")
public class DBOperationsDAO{

	@Value("${jdbc.driver}") private String driver;
}

<context:property-placeholder location="DB.properties"/>

Working with <context:property-placeholder> tag is equal to the working with PropertyPlaceHolderConfigurer Bean class of Spring API..


Developing the Spring Core Module Without XML File:
---------------------------------------------------

For this we need to use the AnnotationConfigApplicationContext to create the IOC container by specifying the Configuration class.The java class that contains the methods to create and return the bean class objects is called as the Configuration class..We @Configuration to configure the ordinary java class as the Configuration class. We use @Bean on the top of the configuration class methods which produces the Objects(To configure those objects as Bean we use the @Bean)

@Bean @Lazy @Scope @DependsOn 

All the methods of the Configuration class that are annotated with @Bean will be executed automatically, the moment IOC container is created by Specifying the Configuration Class..If you want to delay the certain method execution until the ctx.getBean() is called then use the @Lazy Annotation..In order to create the Bean Class Object only after the creating another bean class Object then we can go for the @DependsOn Annotation..

Bean instantiation takes place when the IOC container is created is called as the EagerInstantiation.. Bean Instantiation takes place only when ctx.getBean is invoked is called as the Lazy Instantiation...


Method Replacer using the Annotations:

public  class BankLoanMgmt {
	
	public float calculateIntrestAmount(float pAmt,float rate,float time) {
		 
		System.out.println("BankLoanMgmt.calculateIntrestAmount() ::: compound Intrest Amount");
		
		return  (float)((pAmt*Math.pow(1+rate/100, time))-pAmt);
	}

}

@Component("bankCIAR")

public class BankLoanMgmt_CaculateIntrestAmountReplacer implements MethodReplacer {

	@Override
	
	public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
		
		System.out.println("BankLoanMgmt_CaculateIntrestAmountReplacer.reimplement(-,-,-) :: simple Intrest amount");
		float pAmt=0.0f;
		float time=0.0f;
		float rate=0.0f;
		
		//get  target /original method args values
		
		pAmt=(float)args[0];
		rate=(float)args[1];
		time=(float)args[2];
		//write new logics  (Simple Intrest amount)
		return pAmt * rate* time/100.0f;
	}

}



<bean id="bank"  class="com.nt.target.BankLoanMgmt">
       <replaced-method  name="calculateIntrestAmount"  replacer="bankCIAR"> *****We can use the bean that is configured with @Component("bankCIAR")
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
       </replaced-method> 
    </bean>
    
   <context:component-scan base-package="com.nt.replacer"/>	


100P AnnotationCode:
-------------------


@Configuration
@ImportResource("com/nt/cfgs/applicationContext.xml")				Just avoiding the <context/> tags heree.....
@ComponentScan(basePackages = "com.nt.replacer")
public class AppConfig {

}

<!-- target/main class cfg -->
    <bean id="bank"  class="com.nt.target.BankLoanMgmt">
        <replaced-method  name="calculateIntrestAmount"  replacer="bankCIAR">
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
       </replaced-method>  
    </bean>
    
</beans>



Annotation Based code to collect the values from the Properties files:
-----------------------------------------------------------------------
@Configuration
@ComponentScan(basePackages = "com.nt.dao")							<context:component-scan/> Avoids 
@PropertySource(value = {"com/nt/commons/jdbc.properties",
		                                       "com/nt/commons/jdbc1.properties"})
public class PersistenceConfig {

	@Autowired
	private Environment env;

	@Bean(name="hkDs")
	public  DataSource createDS() {					Third partyBeans are configured
		HikariDataSource  hkDs=null;
		hkDs=new HikariDataSource();
		hkDs.setDriverClassName(env.getRequiredProperty("jdbc.driver"));
		hkDs.setJdbcUrl(env.getRequiredProperty("jdbc.url"));
		hkDs.setUsername(env.getRequiredProperty("jdbc.user"));
		hkDs.setPassword(env.getRequiredProperty("jdbc.pwd"));
		hkDs.setMinimumIdle(Integer.parseInt(env.getRequiredProperty("pool.minsize")));
		hkDs.setMaximumPoolSize(Integer.parseInt(env.getRequiredProperty("pool.maxsize")));
		System.out.println("system property ::"+env.getProperty("os.name"));
		return hkDs;
	}
}


Nested Container example with AnnotationConfigApplicationContext:
-----------------------------------------------------------------
parentCtx=new AnnotationConfigApplicationContext(BusinessAppConfig.class);
childCtx=new AnnotationConfigApplicationContext();
childCtx.setParent(parentCtx);
childCtx.register(PresentationAppConfig.class);
childCtx.refresh();  //To perform pre-instantation of singletonscope beans.

controller=childCtx.getBean("controller",MainController.class);


SpringBoot Example:
------------------

All the some of the ThirdParty Classes (asBeans) will also be automtically configured,without even writing the code based on the Classpath jar files..

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		
//		SpringApplication.run(DemoApplication.class, args);
		
		ApplicationContext ctx=null;
		WishMessageGenerator generator=null;
		//get IOC container
		ctx=SpringApplication.run(DemoApplication.class, args);
		
		System.out.println(ctx.getClass());	 //class org.springframework.context.annotation.AnnotationConfigApplicationContext							
		//get Spring bean class object
		generator=ctx.getBean("wmg",WishMessageGenerator.class);
		//invoke method
		System.out.println(generator.generateWishMessage("raja"));
		//close container
		((AbstractApplicationContext) ctx).close();
		
	}

}

									Spring JDBC:
									------------

Where should we use the JDBC & where should we use Hibernate?

While working with JDBC if you want to process huge amount of records then we need to deal with Single ResultSetObject..While working with Hibernate, if we want to take process huge amount of records then we need to take the multiple objects representing the multiple records..This is the problem & it may crash the system, while creating huge amount of Objects..

Use JDBC for offline application that deals with the huge amount of data and where we don't need the database portability feature.(Changing the DB Software with modifying the codeee..)Ex:Storing and managing the sensus details, political party membership details by perfoming the validation and also correction 

While developing the online(internet applications) that deals with the limited amount of personalized data then we use the Hibernate..

Ex: Online Shopping Mobile recharge Online etc..

While developing the internet application that perfoms the batch processing of huge amount of data then we use the JDBC technology..

Ex: Mobile number activation application that activates the set of numbers at a time..

*** Spring JDBC provides the abstraction over the plain JDBC and simplifies persistence logic development..Instead of using the plain jdbc in offline applications & internet applications that deals with huge amount of data through batch processing it is recommended to use the Spring JDBC..

Plain JDBC code::
----------------

Register the JDBC driver
Establish the connection
Create Statement
Send & execute the SQL Query
Gather results & process Results
Exception Handling
Close the JDBC Objects...

Spring JDBC App:
---------------

Configure & get the JDBC Template Class Object 
Send & execute the SQL Query
Gather results & process results..


Limitations with Plain JDBC:
---------------------------

> Boiler Plate Code problem > Exception Handling is mandatory > Processing the resultset to get the result in desired type is a complex process.
> No support for the proper Tanscation Management


Advanatges of Spring JDBC:
-------------------------

Solves the Boiler plate code problem..Makes the programmer to take care of application specific logics..Raises the unchecked exceptions(subclasses of the DataAccessException class & itself) so the exception is optional to catch and handle..it internally uses the exception rethrowing concepts to convert the checked exception(SQLException) into Uncheked Exception..

Gives various methods to get the records of the resultSet object in the Desired Type..Takes care of opening the connection & close the connection activities...supports the both positional & named params in the SQL Query..

Allows to use the callback interfaces to develop the more & more customized persistence logic development using the plain JDBC code..

Action 							Programmer 						Spring JDBC
-----------------------------------------------------------------------------------------------------------------------------
Configuring the Datasource				Yes
Creating/getting connection											Yes
Creating Statement												Yes
Preparing the SQL Query with Params			Yes
Sending Executing SQL Query in DB S/W			Yes
Iterating through ResultSet if needed.										Yes
Exception Handling												Yes
Transaction Management												Yes
Close the JDBC Objects												Yes


Spring JDBC/ORM modules internally uses the multiple other technologies/Frameworks to develop the persistence logics but translate the exceptions of underlying technology/framework into Spring DataAcessException Hirerachy..

There are five methodlogies to develop the persistence logics in Spring JDBC..

JDBC Template:

1)NamedParameterJDBCTemplate
2)SimpleJDBCTemplate(Removed from Spring 4.0)
3)SimpleJDBCInsert,SimpleJDBCCall
4)Modelling JDBC operations as Java Objects(Mapping the SQL Operations as subclass using the SQLQuery & SQLUpdate Classes..(JDO Style))

Connection Pool Based Connection
--------------------------------
While working with any technique Spring JDBC we need to use the JDBC connection to interact with D/B software.It is recommended to use the jdbc connection pool based connection instead of the direct connection..Don't use the Spring builtin classes like DriverManagerDatasource,SingletonConnectionDatasource etc..to work with spring jdbc connection pool because those classes actually doesn't pool the connection objects more over creates the jdbc connection objects on demand..

If our Spring API is standalone app running outside the server then use the Third party supplied JDBC Connection Pool like C3P0 or apacheDBCp.
If our spring app is deployable in the server then use the jdbc connection pool

Using JDBCTemplate:
------------------

This is the central class of the Spring JDBC provides the abstraction layer on the plain jdbc and simplifies the persistence logic development.. This class takes care of common workflow activities of jdbc programming like opening connection,creating statement,closing connection and etc...but makes the programmer to just provide the SQL query and extract results..This class translates the JDBC generated SQLExceptions into Spring specific unchecked exceptions like DataAccessException.. 

This avoids the programmer to avoid the common errors in ApplicationDevelopment like fogetting to close the JDBC objects.. To create the JDBCTemplate class object we need the jdbc datasource object.. We generally configure the JDBCTemplate class in the Spring Bean configuration file and use that to inject that object into the DAO Class...

There are 2 approches to work with JdbcTemplate:
-----------------------------------------------

1) Using the direct methods(No need of JDbC code) 2)Using the call back interfaces(Need to write the plain jdbc code customized persistence logic)

Direct Methods of JDBCTemplate Class:

Select operations:
---------------

query() queryForXXX() methods:

queryForInt() queryForLong() To execute the query that gives the Single numeric value as result(Ex: select count(*) from student;)

queryForMap(): To execute the query that gives the single record.  select * from student where sno=1001

queryForObject():To execute the query and get the result into predefined BO class object.(Like numeric value, String )

queryForList(): To execute the query that gives multiple records. select * from student

queryForRowset(): To execute the query that gives the jdbc Rowset Object etc..

Note :: If the above methods are executed or called with one argument they internally uses the JDBC Simple Statement Object..

Note:: If the above methods are called with 2 or 3 arguments then they internally uses the JDBC PreparedStatement Object

For the nonselect operations:  update method..

For the Batch Updation:: batchupdate() method and many more..


Example::

private  static final String  GET_EMPS_COUNT="SELECT COUNT(*) FROM EMP";
	private static final String GET_EMP_NAME="SELECT ENAME FROM EMP WHERE ENO=?";
	private  static final String  GET_EMPDETAILS_BY_NO=
			"SELECT ENO,ENAME,SALARY,JOB,DEPTNO FROM EMP WHERE ENO=?";
	private  static final String  GET_EMPDETAILS_BY_DESGS=
			"SELECT ENO,ENAME,SALARY,JOB,DEPTNO FROM EMP WHERE JOB IN(?,?) ORDER BY JOB";
	private  static final String  INSERT_EMP=
			"INSERT INTO EMP(ENO,ENAME,JOB,SALARY) VALUES(?,?,?,?)";
	private  static final String  ADD_BONUS_EMP_BY_DESG=
			"UPDATE EMP SET SALARY=SALARY+? WHERE JOB=?";
	
@Override
	public int getEmpsCount() {
       int count=0;
        count=jt.queryForObject(GET_EMPS_COUNT,Integer.class);
        return count;
	}
	
	@Override
	public String getEmpNameByNo(int eno) {
		return jt.queryForObject(GET_EMP_NAME,String.class,eno);
	}
	
	@Override
	public Map<String, Object> getEmpDetailsByNo(int no) {
		return jt.queryForMap(GET_EMPDETAILS_BY_NO, no);
	}
	
	@Override
	public List<Map<String, Object>> getEmpDetailsByDesgs(String desg1, String desg2) {
		return jt.queryForList(GET_EMPDETAILS_BY_DESGS, desg1,desg2);
		
	}
	
	@Override
	public int insertEmp(int eno,String ename, String desg, float salary) {
		return jt.update(INSERT_EMP, eno,ename,desg,(int)salary);
	}
	
	@Override
	public int addBonusToEmpByDesg(String desg, float bonus) {
		return jt.update(ADD_BONUS_EMP_BY_DESG,(int)bonus,desg);
	}


To provide the global visibility to Object or object refrence it will be placed in the jndi registry having the nick name. Evey web/appserver gives one builtin jndi registry. In server managed jdbc connection pool environment the ConnectionPool will be represented by the DataSource object and its refrence will be placed inside the jndi registry of server for the global visibility having the jndi name.. The apps deployed in the server or running outside the server can access the DatasourceObject refrence from the JNDI registry to get the connection object from the jdbc connection pool. In one server we can create the multiple connection pools representing the multiple databses..The client app that wants to use the connection pool can be there inside the server as the deployable servelt,jsp/EjB component.or can be outside the server as the StandAlone Application.

Witrespect to diagram:
----------------------

TL or PL or Admin makes the server to use the Type1/Type2/Type4 jdbc driver to interact with database software to create the server managed jdbc connection pool having the connection objects. TL/PL/Admin creates the Datasource Object representing the jdbc connection pool places that Datsource object refrence in the jndi registry having the jndi name for the global visibility


In Weblogic software we can create multiple domains and each domain acts as the 1 domain server.Multiple projects of the company uses multiple domain servers of the weblogic on one per project basis. i.e weblogic will be installed only once but we can have multiple domain servers...

Spring gives one builtin Factorybean class to get the object from the jndi registry based on the jndi-name.Bean is JNDIObjectFactoryBean 

While developing the eclipse based webapplications the jar files placed in the buildpath will not be moved to WEB-INF/lib directory directly..For that we need to do the deployment assembly seprately..

To deploy the eclipse webproject in Ntsp27 domain of weblogic.

While working with SpringJDBC in servlet then applicationContext should be object of ClassPathXmlApplicationContext..If it is FileSystemApplicationContext then it will not work..

***Procedure to create the JDBC Connection Pool for the Oracle in WebLogic Server in the Domainserver of GlassFish:

***Procedure to create the JDBC Connection Pool for the Oracle in GlassFish Server in the Domainserver of GlassFish:

***Procedure to create the JDBC Connection Pool for the Oracle in Tomcat Server:


Step1: Make sure tomcat-jdbc.jar file is avaialble in the <tomcat_home>/lib folder..This jar builtin file in tomcat but must be arranged separately for another versions of tomcat. Make sure the ojdbc6.jar is also made available in the server lib folder.

Step2: Place the <Resource> tag in context.xml file..Restart the server.

To use the above jdbc connection pool in web applications we need to place the jndi-name as shown: Java:/comp(prefix)/env/myPool(JNDI Name)

CallBack Interfaces:
--------------------

The method that is called by underlying jvm/container/server etc.. automatically and dynamically is called CallBack Method..The interface that contains such methods is called CallBack Interfaces..Spring provides lots of callback interfaces along with the lot of Template classes.. We can use this CallBack interfaces to write the customized logic to process data and get the data in the customized manner.

For example:queryForMap gives the single record in the form of map object having the column name as key as column values as database column value in map..
But industry standard is to get that record in the BOClass Object.. For this SPring gives the Rowmapper callBack interface.. Various CallBack interfaces of Spring JDBC are:

StatementCallBack--->Allows to work with statementObject
PrepareStatementCallBack CallableStatementCallBack
PrepareStatementCreator--->Provides an object to create the PreparedStatement
PreparedStatementSetter--->Provides the PreparedStatement Object to set the values to queryParam.
RowMapper--->To process the 1 record of ResultSet at a time..
ResultSetExtractor--->To process the multiple records of the ResulSet at a time..

Note:: The implementation Class methods of the CallBackInterfaces will be called by the JDBCTemplate Internally

LookOut for the DAOProj5-JdbcTemplateCallbackInterfaces: in the workspace
-------------------------------------------------------------------------

@Repository("studentDAO")
public class StudentDAOImpl implements StudentDAO{

	private static final String  GET_STUDENT_BY_NO=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SNO=?" ;
	private static final String  GET_STUDENTS_BY_CITIES=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SADD IN(?,?,?)" ;
	
	@Autowired
	private JdbcTemplate jt;

	@Override
	public StudentBO getStudentByNo(int no) {
		return jt.queryForObject(GET_STUDENT_BY_NO,new StudentMapper(),no);
	}
	
	private  static class  StudentMapper implements RowMapper<StudentBO>{

		@Override
		public StudentBO mapRow(ResultSet rs, int rowNum) throws SQLException {
			//convert   RS record to StudentBO class object
			StudentBO bo=new StudentBO();
			bo.setSno(rs.getInt(1));
			bo.setSname(rs.getString(2));
			bo.setSadd(rs.getString(3));
			bo.setAvg(rs.getFloat(4));
			return bo;
		}//mapRow(-,-)
	}//inner class
	
	
	@Override
	public List<StudentBO> getStudentsByCities(String city1, String city2, String city3) {
		
		return  jt.query(GET_STUDENTS_BY_CITIES, new StudentExtractor(),city1,city2,city3);
	
	}
	
	private  static class  StudentExtractor implements ResultSetExtractor<List<StudentBO>>{
		
		@Override
		public List<StudentBO> extractData(ResultSet rs) throws SQLException, DataAccessException {
			
			System.out.println("StudentDAOImpl.StudentExtractor.extractData(-)");
			List<StudentBO>  listBO=null;
			StudentBO bo=null;
			//copy  RS object records to  List of StudentBO collection
			listBO=new ArrayList<>();
			while(rs.next()) {
				//get each record into StudentBO class object
				bo=new StudentBO();
				bo.setSno(rs.getInt(1));
				bo.setSname(rs.getString(2));
				bo.setSadd(rs.getString(3));
				bo.setAvg(rs.getFloat(4));
				//add each BO class obj to List colleciton
				listBO.add(bo);
			}//while
			return listBO;
		}//extractData(-)
	}
	
	@Override
	public List<StudentBO> getStudentsByCities1(String city1, String city2, String city3) {
		 List<StudentBO> listBO=new ArrayList<>();
		 jt.query(GET_STUDENTS_BY_CITIES, new StudentCallBackHandler(listBO), city1,city2,city3);
		 return listBO;
	}
	
	private static class StudentCallBackHandler implements RowCallbackHandler{
		 private List<StudentBO> listBO;
		
		public StudentCallBackHandler(List<StudentBO> listBo) {
			
			this.listBO=listBo;
		}
		
		@Override
		public void processRow(ResultSet rs) throws SQLException {
			
			System.out.println("StudentDAOImpl.StudentCallbackHandler.processRow(-)");
			
			StudentBO bo=null;
			//covert RS record into BO clss object
			bo=new StudentBO();
			bo.setSno(rs.getInt(1));
			bo.setSname(rs.getString(2));
			bo.setSadd(rs.getString(3));
			bo.setAvg(rs.getFloat(4));
			listBO.add(bo);
		}
		
	}
}


Try to implement the same methods with the InnerClasses & with the LambdaExpressions..

@Repository("studentDAO3")
public class StudentDAOImpl3 implements StudentDAO{

	private static final String  GET_STUDENT_BY_NO=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SNO=?" ;
	private static final String  GET_STUDENTS_BY_CITIES=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SADD IN(?,?,?)" ;
	
	@Autowired
	private JdbcTemplate jt;

	
	@Override
	public StudentBO getStudentByNo(int no) {
		StudentBO bo1=null;
		bo1=jt.queryForObject(GET_STUDENT_BY_NO,   // arg1
									 new BeanPropertyRowMapper<StudentBO>(StudentBO.class),
				                              no //arg3 
				                              );
		return bo1;
	} //method

	@Override
	public List<StudentBO> getStudentsByCities(String city1, String city2, String city3) {
		List<StudentBO> listBO=null;
		BeanPropertyRowMapper<StudentBO> bprm=null;
		//create BeanPropertyRowMapper class obj  that hepls to copy each record into  one BO class obj
		bprm=new BeanPropertyRowMapper<StudentBO>(StudentBO.class);
		listBO=jt.query(GET_STUDENTS_BY_CITIES, //arg1
				                  new RowMapperResultSetExtractor<StudentBO>(bprm), //args2
				                   city1,city2,city3 //arg3 (Var args)
				                    );
		
		return listBO;
	}
	
	@Override
	public List<StudentBO> getStudentsByCities1(String city1, String city2, String city3) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
}









































































=======
C C++ Java are the programming languages.. JDBC JSP Servlet JavaMail JTA(Java Transcation API) JPA(JAVA Persistence API) JMS(Java Messaging Service) are the 

Technologies...Struts Spring Hibernate etcc.. are the java frameworks

Programming Languages:
--------------------

It is directly installed software & it is base for creating the software appplications...Defines the semantics and syntaxes for Programming.

Technologies Frameworks Tools Db software and OS are bulitin on the top of the programming languages..

Software Technology: It provides the Set of rules and guideliness to devlop the software using the programming language support...Software technology is not installable but the software created following the guidlenss & rules of the technology are the installable...Working with this software is nothing but the working with this software technologies..

In Java environment technogy rules are nothing but Interfaces...Classes provide the guideliness and abstract classes provide the both rules & guideliness

Software Technology is one Jar we can call API jar... Imeplemntation of technologies by vendors  provide another JAR.. We should use both of them inorder to work with the software..

Java Provide the JDBC API rules and guideliness to provide the implementation of Driver classes.. Working with the Drivers is nothing but working with JDBC 
technologies....

JDBC Technology... JDBC Drivers(Softwares)

Open Technologies and Proprietary Technologies:

Rules and guideliness of technology are open to all software vendor compaines to develop the software...Examples are all the Java Technologies

Proprietary Technologies::Venodr companies who has given the technologies are allow to develop the software based on the technology.. Microsoft Technologies


Frameworks:
----------

Framework is a installable software that uses the existing technolgies internally to simplify the application development having the ability to generate the common logics of the application internally.. Framework is the installable software that provides the abstraction layer on the existing technologies to simplify the application development process..

While developing the applications using the Software Technologies/(Softwraes impl) programmer has to develop the both the common logics and specific logics of the application..While working with frameworks the programmer has to develop only the application specific logics because the common logics will be generated by the framework dynamically...

Even the framework uses the technology internally but it never makes the progrmmaer to know about it.. This is nothing but providing the abstarction layerr..(hiding the implementations/internals)

Hibernate uses the JDBC Driver Softwares generates the logics dynamically and makes the application development process simplify..

While working with only Software Technology we need to write the common logics and application specific logics..Common logics are called as Boiler plate code.. Frameworks take care of all the Boiler Plate code..

Based on the kind of the applications and logics we develop there are 3 types of the Java Frameworks..

WebApplication Framework:
-------------------------
Provides the abstraction layer on the servlets and JSP technology.. Simplifies the MV architecure based web application development..

JSF,ADF-->Oracle  Struts-->Apache 	WebWork-->OpenSymphony   - Spring MVC-->Interface 


ORM Framework:
-------------

Provides the abstraction layer on the JDBC technology.. Simplifies the Object based O-R mapping persistence logic development..Allows the portability/DB independent persistence logic devlopment..

Hibernate--> RedHat   TOPLINK--->ORACLE  OJB,IBatis-->Apache  JDO--->Adobe

We not required to build the queries.. IF we build queries when we change the DB then queries may not be compatabile.. So we should depend on the framework to build the queries.. Allows for the Object oriented style of building the queires..


Application Framework:
---------------------

Provides the abstraction layer on multiple technologies like JDBC servlets JSP JNDI JMS JTA JPA JavaMail EJB RMI etc.. Allows to develop the all kinds of the logic like the business logic,persistenc logic,presentation logic, integeration logic.. Allows to develop all kinds of the applications like the standalone applications webapplications distributed applications..

Based on the mode of development there are two kinds of Frameworks:
------------------------------------------------------------------

Invasive Framewrok:: Here the classes of the application has to extends or implement from the Framewrok api classes/interfaces. This process makes the application classes as tightly coupled classes of the framework.. We cannot change the Framework of application/project by just changing the libraries..

Non Invasive Framework:Here the classes of the application need not has to extends or implement from the Framewrok api classes/interfaces.so our application classes are not tightly bound with framework..We can change the framwork of the application/project by just changing the libraries(jar files)


Evaluation of Spring:
---------------------

Applets -->For Gaming	1995
Java Bean---> for Blogic/Service logic development 1996
Disadvanatges:: Can't apply the services, can't be acessed from remote clients

Security transactions logging Connection pooling etcc are called the service/middleware services..

EJB---> Used for Busines logic and services logic development

Advantages:: Allows both local and remote clients.. Allows to apply the middleware services..

Disadvantage:: Hevay Weight and Complex.. EJB is suitable for the Banking Projects


Spring(2003):: Intially used for the Business/Services logics development with ordinary classes allowing to apply the middleware servicess..Now spring can be used to develop all kinds of appplication logics in light weight environment and allowing to apply the middleware services..

IS spring is replacement for the STRUTS? Using the struts we can develop only the web applications .. there is no provision in struts to develop and use the middleware services/aspects(Security logging etc..) Using Spring we can develop all kinds of the applications and all kinds of the logics..

Spring acts as UMBERALLA/Abstraction over all the JAVA technologies to devlop the applications with all kinds of logics like logging/security/transcation/
aop in Hassle free manner with avoiding the all Boiler Plate code..


***Spring is providing abstraction layer even on the Frameworks like Hibernate Toplink Ibatis JDO OJB JPA ADF JSF Struts WebWork RichViewSupport Jasperreports FreeMarker Excel PDF Spring Portlet MVC

Spring Core:: This module is base for all the modules,designed for supporting the dependency injection(injecting values to objects dynamically)

Spring JDBC: Provides the abstraction over the plain jdbc to simplify the jdbc style persistence logic development and exception rethrowing concept is used to design the DAOException hirerachy

SPRING ORM: Provides the abstraction layer on the multiple ORM framework like Hibernate and simplifies the Object Based ORMapping Peristence logic

SPring Web: Provides the plugin to make the spring applications communicatble from other web framework applications like Struts,JSF and etcc..applications

Spring Web MVC: Springs own framework to develop the MVC architecture based webapplications with plain classes and aribitary methods of classes

Spring Context: Provides the abstraction layer on the multiple JSE and JEE module technologies to simplify the development of the common logics..

Mailing Applications, Distribution Applications, Messaging Applications and scheduling Applications etc...

Spring AOP: Provides the new Methodlogy of programming to develop aspect/middleware service logics and apply them on the Spring Applications...

Before AOP:

Class Bank{

	public void withdraw(){
		
	//Security Logic
	//Logging Logic
	//Transcation Logic
	//withdraw logic
	
	}

	public void deposit(){
		
	//Security Logic
	//Logging Logic
	//Transcation Logic
	//Deposit logic
	
	}
}

With AOP:

Class Bank{

	public void withdraw(){
		
	//withdraw logic
	
	}

	public void deposit(){
		
	//Deposit logic
	
	}
}

Spring 3.x is compatabile with 1.5 and Spring 4.x with jdk 1.6 & supports all the features of Java8.

Spring 4.x Messaging a subframework in Spring 4.x is given alternate to the JMS to get the messages based asynchronous communications between the components..Asynchronous commmunications allow the client to give next request or the client side operations wiht out giving the response for current request from server.. 

WebSocket is the weblevel protocol that is designed on the top http protocol for full 2 way communication..


M-->Model-> Data + Business Logic + Persistence Logic
V--> View -->Presentation logic
C-->Controller-->Integration Logic

Integration logic controls and monitors all activities of application execution.. It is responsible to get communication between the view layer and model layer componenets

DAO:: The java class that seprates the persistence logics from another logics and makes the persistence logics as the reusable and flexible logic to modify is called as DAO

JDBC is light weight but doesnot allow to develop the Object Based Persistence logic..EJB entity Beans are heavy but allows to develop the object based persistence logic.. To overcome the both probelms we can use the Hibernate...

EJBSessionBeans are completely replaced with the help of the Spring JEE/Beans/SpringWebServices..With the help of all the Middleware service logics Secuirty logging Transcations etcc.. being implemented

Spring Definition:
-----------------

Spring is the OpenSource, Light Weight, loosely coupled,aspect oriented,dependency injection based java application framework to develop the various java applications..

What is Opensource?Not only freesoftware they also expose the source code.. Along with installation we get source code container jar files..

LightWeight: Spring gives the 2 light weight containers which can be activated anywhere in the application...To work with spring we dont need the any webserver software or the application server..

We can use the specific modules of Spring without having any link with other modules..We can use the Spring Core alone or the SpringCore + Spring DAO module together without anylink with other modules..If the dependency is less between the modules, then they are called as Loosely coupled components 

In the Spring framework Spring CORE module is the base module for all the modules..We should use every module along with Spring Core module..That is only dependency..But remaining modules can be used alone without having dependency with any other modules.. So dependency is very less between all the modules..
This makes the spring as loosely coupled framework

AOP is the new methodlogy of programming that compliments the OOP to seprate the secondary middleware service logics from the Primary Business logics and allows them to link dynamically at runtime through some configuration. This gives the advanatges of reusable middleware service logics and flexibility of enabling and disabling middleware service logics on primary logics(like security and transcations etc...)

Dependency LookUp:
------------------

If the resource/class/Object is searching and getting the dependent values from other resources then it is called as dependency Lookup..Here the resource itself pulls the dependent values..

-->The way we get the Objects from JNDI registry is called Dependency LookUp..The way we get JDBC connection Objects from Connection pool

Dependency Injection(Inversion of Control):
------------------------------------------

If the underlying framework/server/container/runtime(JRE)  assigns the values to resource/classes/Objects dynamically at runtime then it is called Dependency Injection..Here the dependent values are pushed to the resource..

Examples:JVM calling the constructor automatically to assign the intial values of Object when the Object is created..Servlet Container injects the servlet config Object once the servlet instance is created..


POJO Class: Ordinary java class that is not extending from the any techonloy/framework api class or not implementing the any technology/framework api interfaces is called as POJO class

Ex: class Demo{} class Test implements Serializable{} class Test extends Demo{} class Test extends Thread{}---->POJO examples

class Test extends HttpServlet{} class Test Implements java.sql.Connection{}---->NON POJO examples

class Test{
	void m1(Statement st){}  Test is POJO class
}

class Demo implements java.rmi.Remote{}  class Test extends Demo{}---->Both the Demo & Test are not POJO classess

@Entity
class Test{} Test is POJO class


Don't consider the Annotations and APIS used inside the methods of class to check whether the class is POJO or not...



23-02-2021:
----------
POJI: Plain Old Java Interface It indicates the interface without specialities (ordinary interfaces) not extending from the technology/framework Interfaces

The frameworks that supports the POJO/POJI model programming is called as Non Invasive Frameworks or LightWeight Frameworks

Ex: Hibernate Spring and Struts 2.x

JavaBean:
--------

The javaclass that is developed with some standards..Must be the public class and should not be final or abstract class. Can be implementing Serializable interface if need.. Must have Zero Param constructor direct or indircet..Every Bean property should have setter & getters

In realtime javabean is used as the Helper class to represent the data with multiple values in the form of Object and send those Objects from one layer to another layer. It is the accpetable format irrespective of the technologies used in the Multiple layers..

The JavaBean class whose Object holds the input values given by the client/enduser is called VOClass...The java bean class which holds the data needed for the persistence operations is called BOClass.The javabean class object which holds the data that is shippable across the network is called DTO class...

BeanClass/ComponentClass:
------------------------

The javaclass that contains member varaibles and methods having the business logic manipulating the data of member varaibles..

Class CardProcesser{

private int cardNo;

public int processCard(int cardNo){-----BLogic-------}

public boolean blockCard(int cardNo){-------BLogic---------}

}

Bean/Component class can extend or implement the any Framewrok Class/Interface..

SpringBean:
----------

The javaclass whose Object can be managed by the SpringContainer is called SpringBean..Spring Bean can be POJO/JavaBeanClass..

Bean/Component class whose object is created/maintained by the spring container can also be called as the Spring Bean..

We can't take the Interfaces/Abstract classes as the springBeans because we cannot create the Objects of the Interfaces/Abstract classes..Spring Bean can be the userdefined/predefined or third Party classes..

Any F/w class or any class that is extending the F/w class can be called as the SpringBeans

Sprin Bean can be Pojo Class? Yes 
Every Java Bean is a Pojo class? Yes
Every Pojo class is javabean? No
Every Spring Bean is javaBEan?NNo
Spring bean can be JavaBean ? Yes
Spring Bean cannot implement the Spring API Interfaces? No
ANy Component class can be taken as the Spring Bean ? Yes

Spring Container:
----------------

Any javaclass or application that can manage the life cycle of given reosurces(springbeans) is called the container..

BeanFactory:Perfoms the spring beans management and Dependency injection

Application COntext:: Internally uses the BeanFactory so can perfom the advnaced operations along with the  spring beans management and Dependency injection

Spring containers are light weight but not alternative for the Servlets/JSP containers (Heavy Weight)

BeanDactory factory=new XMLBeanFcatory(Resource:To xml spring bean confiuration file)

						Spring CORE MODULE:

Talks about the Spring Bean Lifecycle managemet and dependency Injection..When it is used alone we can develop the standAlone Applications..When used along with other technologies we can develop model layer business logic by taking the advntage of the dependency Injection..

Talks about the Spring Bean lifecycle Management and Dependency Injection..


Dependency Injection(Inversion of Control):
------------------------------------------

If the underlying framework/server/container/runtime(JRE)  assigns the values to resource/classes/Objects dynamically at runtime then it is called Dependency Injection..Here the dependent values are pushed to the resource.

Setter Injection:: Container uses the zero param const for creating the bean clss object and calls the setter method to inject the dependent value
Constructor Injection: Container uses the Parameterized constructor to create the bean class Object and inject the values
Interface Injection
Method Injection
Lookup Injection

Any file name can be taken as Spring Configuration file.. but it is recommended to take the applicationContext.xml file in StandAlone applications

In SpringBean configuration file: we configure the SpringBeans the Dependency injection configuration and SpringBean lifecycle configuration etcc...

We must supply the springbean configuration file while activating the SpringContainer..Every Spring bean is identified by its bean id(used for dependency injection with ref property)

<property> tag perfoms the setter injection..

public class WishMessageGenerator {

private String name;
private  Date  date;

setter;getter

}

<bean id="dt" class="java.util.Date"></bean>
 <bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/>

Setter Injection: Spring uses the zero param cons to create the Objects of Date class and WishMessageGenerator..

Constructor Injection: Spring uses the zero param cons to create DateClass Object and two param constr for the WishMessageGenerator

<bean id="dt" class="java.util.Date"></bean>
 <bean id="wmg" class="com.beans.WishMessageGenerator">
  <constructor-arg value="Raja"/>
 <constructor-arg ref="dt"/>
 </bean>

 res=new FileSystemResource("src/main/java/com/cfgs/applicationContext.xml");
		 //create BeanFactory IOC container
		BeanFactory factory=new XmlBeanFactory(res);
		 //get Target bean class object
		 Object obj=factory.getBean("wmg");
		 //typecasting
		WishMessageGenerator generator=(WishMessageGenerator)obj;
		 //invoke the  method
		 result=generator.generateWishMessage();


Note:: Every Spring Bean should have unique Id.. We can also configure the same class with multiple Ids..

Dependencies:
------------
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-context</artifactId>
<version>5.3.4</version>
</dependency>

aop beans context core expression jcl(logging) jars will be downloaded...

Steps::

1) checks whether xml file is wellformed and valid document or not 2)Creates the empty logical IOC container in jvm memory
2) Creates the SaxParser to read the xml file data and maintain it as inmemory metadata or inmemomry configuration...
3) factory=new XmlBeanFactory(res); returns the XmlBeanFactory Object representing IOC container
4) factory.getBean("wmg",WishMessageGenerator.class); For the "wmg" id inmemory data configuration is looked and Loads the WishMessageGenerator class into    JVM.. class.forName("WishMessageGenerator.class").newInstance();
5) Looks the <property> tag with name and calls the setter method in the WishMessageGenerator class instance
6) Looks the <property> tag with date and identifies the dependency Object DateClass.. It loads the DateClass Create Objects and calls setter method on 
  WishMessageGenerator class to inect the date Object...

						newInstance Method:
						------------------	

Class c1=Class.forName(args[0]); loads the given class and return the java.lang.Class Object..  static flow is executed here..ClassNotFoundException thrown
Object obj1=c1.newInstance();	 Creates the Object of the Class...zero Param constructor is executed here..When we create the Object below exception are thrown..InstantiationException(If underlying class is abstract/interface), IllegalAccessException(for Private COnstructor)
				
public T newInstance(Object... initargs)
  throws InstantiationException, IllegalAccessException,
         IllegalArgumentException, InvocationTargetException

Parameters: This method accepts initargs as the parameter which is an array of objects to be passed as arguments to the constructor call. The values of primitive types are wrapped in a wrapper object of the appropriate type (e.g. float in Float)

Return value: This method returns a new object created by calling the constructor this object represents.

Exception: This method throws following Exceptions:

IllegalAccessException: if this Constructor object is enforcing Java language access control and the underlying constructor is inaccessible.
IllegalArgumentException: if the number of actual and formal parameters differ; if an unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a parameter value cannot be converted to the corresponding formal parameter type by a method invocation conversion; if this constructor pertains to an enum type.
InstantiationException: if the class that declares the underlying constructor represents an abstract class.
InvocationTargetException: if the underlying constructor throws an exception.
ExceptionInInitializerError: if the initialization provoked by this method fails.

 public static void main(String... args)  throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException 
    { 
          // An array of constructor 
        Constructor[] constructor = Test.class.getConstructors(); 
          // Apply newInstance method 
        Test sampleObject = (Test)constructor[0].newInstance(); Invoke the constructor
          System.out.println(sampleObject.value); 
    } 

class Test { 
  
    String value; 
  
    public Test() 
    { 
        System.out.println("New Instance is created"); 
        value = "New Instance"; 
    } 
} 

Constructor[] constructor = Test.class.getConstructors(); or use the class.forName
Test sampleObject = (Test)constructor[0] .newInstance("New Field"); Passing the parameter to the Single Param Constructor

If we configure the both setter and constructor injections then the bean property values given by the setter injection will remain final values becuase the setter method executes aftre the execution of constructor injection..

<bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/> 
 <constructor-arg value="Raja"/>		Object is created only with Two Param Constructor.. Setter Methods will be used for injecting values
 <constructor-arg ref="dt"/>			again...
 </bean>

Order: Constructor Injection followed by Setter Injection... Object is created only once.. not created in the both cases..

If the spring bean class is configured without injections or only with setter Injection(for one/more) properties then container uses the 0-param constructor
If any property is configured for the constructor injection then it uses the parameterized constructor to create the bean class Object

public class WishMessageGenerator {

private String name;
private static Date  date;
	
public WishMessageGenerator(String name,Date date) {
		
		System.out.println("Wish Message generator:: Two Param Cons");
		this.name=name;
		this.date=date;
	}

	public static void setDate(Date date) {
		System.out.println("WishMessageGenerator:: setDate(-)");
		WishMessageGenerator.date = date;
	}
	
	public void setName(String name) {
		System.out.println("WishMessageGenerator:: setname(-)");
		this.name = name;
	}
}

We can also take the static properties also for creating the springbeans..

bean id="wmg" class="com.beans.WishMessageGenerator">
 <property name="date" ref="dt"/>
 <property name="name" value="Muni"/>				You can perfom the constructor injection or the setter Injection
<!-- <constructor-arg value="Raja"/>
 <constructor-arg ref="dt"/>
  --></bean>

What is difference between the FileSystemResource and ClassPathResource?

Can locate the given springbean file from the specified path of file system..Here we can pass the absolute path or the relative path..

ClassPathResource can locate the spring bean file from the dircetories/jar files that are added to classpath/buildpath..

ClassPathResurce resource=new ClassPathResource("applicationContext.xml")--->Finds the xml file from jar or classpath.


HAS-A relationship:

Createing the dependent class object in the target class and using..

Limitations::Instead of the DTDC courier if flipkart wants the another courier we need to modify the target class.. If the delivery() changed to supply() in DTDC class then also the filipkart class code needs to be modified
>TightCoupling

Using the Help of Factory class to create the Objects and using the Factory class as dependent in Flipkart(Target Class):
If the flipkart wants to use the BlueDart it needs the BlueDartFactory and if it needs DTDC then Flipkart class has to change to DTDCFactory Class
>Same as first approach.. TightCoupling is observed..

Approach3:

class Flipkart{
	
	public void purchase(){
	
	IntialContext ic=new IntialContext();  DTDC dtdc=(DTDC)ic.lookup("cr"); dtdc.deliver();
	
	}
}

If the Flipkart wants the BuleDart Object instead of DTDC object we need to place that object in JNDI registry..
>Same as the first approach.. tight coupling

Approach 4: Flipkart class extending from the DTDC class.

class DTDC{
	deliver(){}
}

class Flipkart extends DTDC{

	purchase(){
		deliver();
}

}

Flipkart class cannot extends more than one dependent class... In order to change we need to change the flipkart class to extend BlueDart Class.. 
>Same as first approach.. We need to change the FlipKart Class.


Approach 5: Making the underlying container to inject dependent Objet to target Object..Using the dependency Injection(setter/constructor injection)


The approach 5 is similar to approach 1& 2 only difference is the underlying container is managing the dependency in the approach5 where as the programmer is managing the dependency in the approach 1 & 2

Limitations: Approach 5 is good towards the mangaing the dependecy injection but inorder to achieve the loose coupling we shouldn't directly work with dependent class in the target class..it is recommended to make all the dependent classes implementing the one common interface having the common method declaration.So that we start using this common interface in the target class


In the flipkart class we are not working with the implementation class directly we are workign with the interface varaible so the underlying can be able to inject any implemntation class Object without chainging/touching the source code of the FlipKart(TargetClass.) We Mark @Primary on the implementation class Objects without touching the Target classes.. If it is the Predefined beans then we have touch the target using the @Qualifer() to change the beanName..

To achieve the loosely coupling in Spring we use the : Dependency Injection & POJI Model programming


In the Spring Bean File::

<property name="msg" value="Hello"/> can be written as the <property name="msg"><value>Hello</value></property>

<property name="date" ref="dt"/> can be written as the <property name="date"><ref bean="dt"/></property> <property name="date"><ref local="dt"/></property>


Design Patterns:
---------------

Which comes as the best solution for the reoccurreing problems of the application devlopment..Design patterns are the best practisces for utilizing the software language technologies and Frameworks effectively in the application development..

Strategy Pattern: While developing the multiple classes having the dependency it is recommended to follow this Design pattern..This pattern is not a spring pattern, it can be used anywhere since spring manages the dependency between the classes, it is recommended to use this pattern while developing the spring application....Strategy pattern is all about implementing the 3 principles.

1) Prefer the composition(HAS-A) over inheritance
2) Always code for the interface never code for the implementation classes---->Loose Coupling
3) Code should be open for the extension and closed for modfication

If the one class creates the Object of other class to use its logics then it is called as the implementation..(HAS-A relationship)

What are the disadvantages of the Inheritance? It doesn't support the multiple inheritances and code becomes easily breakable

Code must be open for the extension and must be closed for the modification:
----------------------------------------------------------------------------

If we follow the second principle perfectly by taking the methods of implementation classes A& B our code becomes closed for the modification and open for the extension..Similary it allows the more implementation classes for interface x having the new logics...This makes the code open for the extension


Flipkart class wants the logics of the DTDC class or blueDart class, but it is not inheriting from those classes but getting the objects of those classes through composition.. BlueDart ,DTDC classes are implementing the Courier(I) or their objects are assigned to Flipkart class through Courier(I)

By making the delivery() method of BlueDart or DTDC class as final methods we can keep that code closed for the modificaton and we can develop the new implementation class for the COurier(I). If the new Courier service like FirstFlight is required for the Flipkart class


Inside the static Block exception should be thrrown:: They need to be Handled properly using the try catch..


How to configure the Factory as the Bean?

	private int sno;
	private String sname;
	private String sadd;
	private  float avg;
	
public Student(int sno, String sname, String sadd, float avg) {
	    System.out.println("Student:: 4-param constructor");
		this.sno = sno;
		this.sname = sname;
		this.sadd = sadd;
		this.avg = avg;
	}

If Bean is configured like this then::

 <bean id="stud"  class="com.nt.comps.Student">
       <!--  <constructor-arg value="1001"/>
        <constructor-arg  value="raja"/>
        <constructor-arg  value="hyd"/> -->
        <constructor-arg value="56.77f"/>	String can't be converted to int
</bean>
UnsatisfiedDependencyException: Error creating bean with name 'stud' \src\main\java\com\nt\cfgs\applicationContext.xml]: Unsatisfied dependency expressed through constructor parameter 0: Could not convert argument value of type [java.lang.String] to required type [int]: Failed to convert value of type 

Resolving the Constructor Params: 

Resolving/Identifying the Params in Constructor Injection:
----------------------------------------------------------

We generally configure the dependent values of constructor injection in the order the paramas of constructor are avilable..But we can mismatch this order during the configuration if we can identify the params using the index type or name.. before Spring 3.x only

<constructor-arg value="" type="float/int/string"/>  <constructor-arg value="" index=""/> 

Based on index:

 <bean id="mk"  class="com.nt.beans.Marks">
       <constructor-arg  index="2" value="70"/>
       <constructor-arg index="1"  value="80"/>
       <constructor-arg  index="0"  value="90"/>
    </bean>

Based on Type:

<bean id="emp"  class="com.nt.beans.Employee">
        <constructor-arg value="raja"  type="java.lang.String"/>
        <constructor-arg  value="1001" type="int"/>
        <constructor-arg value="60000.55f"  type="float"  index="0" name="salary"/>
    </bean>
    
Based on Name:
@ConstructorProperties({"no","fname","sub"})  public con(int no,String fname,String sub)
<constructor-arg value="" name=""/>

In Spring 3.x can't get the parameter names of constructor directly until the parameter names of constructor directly configured using 
@ConstructorProperties({"no","fname","sub"})

in Spring 4.x IOC container can recognise the constructor parameter names directly ..

<bean id="st"  class="com.nt.beans.Student">
        <constructor-arg name="total"  value="270"/>
        <constructor-arg name="sno"  value="342"/>
        <constructor-arg name="sname" value="karan"/>
        <constructor-arg name="sadd"  value="hyd"/>
    </bean>



Cyclic Dependency: If two beans are dependent on each other then we can say that they are in the cyclic dependency.. Spring container can't perfom the cyclic dependency injection through the constructor injection but can perfom through the setter injection

<bean id="a1" class="com.nt.beans.A">
<constructor-arg ref="b1" />
</bean>

<bean id="b1" class="com.nt.beans.B">
<constructor-arg ref="a1" />						
</bean>

a1=factory.getBean("a1",A.class);

Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b1' defined in file applicationContext.xml]: Cannot resolve reference to bean 'a1' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a1': Requested bean is currently in creation: Is there an unresolvable circular reference?
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:342)


To solve this error we should follow setterInjection on the both the classes...

We can also perfom the Cyclic dependncy vy taking one bean class with the setter Injection & other Bean class with Constructor Injection..

<bean id="a1" class="com.nt.beans.A">
	<!-- <property name="b" ref="b1"></property> -->   
		<constructor-arg ref="b1" />
	</bean>

	<bean id="b1" class="com.nt.beans.B">
		<!-- <constructor-arg ref="a1" /> -->
		<property name="a" ref="a1"></property>
	</bean>


a1=factory.getBean("a1",A.class); You cannot do like this till will still be CyclicDependency error..

<bean id="a1" class="com.nt.beans.A">
<property name="b" ref="b1"></property>
<!-- <constructor-arg ref="b1" /> -->
</bean>
<bean id="b1" class="com.nt.beans.B">
<constructor-arg ref="a1" />
<!-- <property name="a" ref="a1"></property> -->
</bean>

a1=factory.getBean("a1",A.class); if you have to call the other bean the you need to reverse the configuration...so better take the Setter Injection on the both the Beans that is the Best Approach

When We should go for the setter Injection and when to go for the constructor Injection:
----------------------------------------------------------------------------------------

IF the bean class contains only one property or all the properties of the bean class should participate in the Dependency Injetction then go for the constructor injection..Because the constructor injection is faster

If the bean class contains N no:of Properties & no need of making all the properties to participate in the Dependency Injection go for the setter Injection..

Ex:In the above case if you have to go with the constructor injection then we should make n! no:of constructors to support the constructor injection in all the ways...


Difference bettwen the setter & Constructor Injection:: Bean class Object created using the zero param constructor..Bean class object created using the single/multiple param constructor....Cyclic Dependency is supported using the setter injection.. Not supported using the constructor injection

perfoms the injection after the creation of the bean class Object..So it is bit delayed..perfoms the injection while creating the bean class Object so there is no delay in injection

Inner Bean:
---------

Placing the <bean> tag inside the <property> or <constructor-arg> tag..If you want to use the certain bean as the Dependent bean for only one Target class then configure as the Inner Bean other wise configure as the Normal Bean...Inner Beans cannot be accessed from Client App..BeanId is also not required to configure..

<bean id="paymentGwBean" class="com.java2novice.beans.PaymentGateway">
        <constructor-arg>
           <bean class="com.java2novice.beans.Order">
                <property name="item" value="Java2Novice" />
                <property name="price" value="RS 22.50" />
                <property name="address" value="Bangalore" />
            </bean> 
        </constructor-arg>
    </bean>



<bean id="kohli"  class="com.nt.beans.ProffesionalCrickter">  <!-- outer bean cfg -->
        <constructor-arg value="virat kohli"/>
         <constructor-arg name="bat">  
             <bean    class="com.nt.beans.CricketBat"/>  <!--  inner bean cfg-->
         </constructor-arg>
     </bean>
     
     
     <bean id="dhoni"  class="com.nt.beans.ProffesionalCrickter">
        <constructor-arg value="dhoni"/>
         <constructor-arg name="bat">  
             <bean  class="com.nt.beans.CricketBat"/>
         </constructor-arg>
     </bean>



Limitations of the Inner Bean :: 

1) Inner Bean cannot be used as dependent bean for the multiple other beans.. 2)Inner Bean Object cannot be accessed from the client Applications

Can we configure the SpringBean class with out Bean iD?

Yes container generates the default bean id using the notation...<pkg>.<BeanClassName>#n   n=0,1,2,3.....

<bean class="com.nt.beans.Flipkart"></bean> BeanId will be  com.nt.beans.Flipkart#0

Configuring the springbean with the beanid is not mandatory but it is recommendation.. 

******Note:
In spring applications we cannot make the IOC conatiner to inject the end user supplied values to beans properties..All these configurations are dependency management related congigurations..

Spring Supports the Dependency Injection On Following Properties:
--------------------------------------------------------------

1)Simple Properties Primitive DataTypes and String's  use the value attr or <value>	
2) Refrence/Object Type properties ref attr or <ref>..We need to configure the dependent datatYpe first and then configure
3) Collection Properties (Array	<list> 	List	<list> 	Set	<set> 	Map	<map> Properties	<props>)

By using the tags internally Objects will be created just we need to assign the values..

private List<String> names;private String[] names;<list><value></value><value></value></list>

private Set<String> phoneNums;<set><value></value><value></value></set>

private Map<String,String> facultySubjects;  <map><entry key=""><value></value></entry> <map><entry key="" value=""></entry>

<map><entry><key><value></value></key><value></value></entry>

******Instead of <value> tag you can use the <ref> if you have the beans in List Set Map..<ref bean="sysdate"/>

Properties Allows Key& value pairs as the Strings..

<property name="empDesgs">
<props>
<prop key="Anil">Clerk</prop>
<prop key="Anil">SE</prop>
</props>
</property>

Checkout the example of NaatrazSir  IOCProj12-CollectionInjection

Injecting the Null Values:	Useful in cons injec when all the values need to injected and for the certain ref type property and we cannot proevide the value

<constructor-arg name="something"><null/></constructor-arg>

but in the setter injection we can avoid it without configuring it..Null is automatically Injected..


Bean Inheritance:
---------------- 

We use the inheritance for the reusability and extensibility.Bean inheritance is no way related with the class level physical inheritance..It is all about the xml file level bean configurations inheritance..

When we want to configure the same class Multiple times as the Spring Beans we can reuse of bean properties configuration across the multiple beans configurations


<bean id="pulsor1" class="com.beans.Bike">
<property name="id" value="TS080111"/>
<property name="make" value="Bajaj"/>
<property name="engineCC" value="150"/>
</bean>

<bean id="pulsor2" class="com.beans.Bike">
<property name="id" value="TS0802222"/>
<property name="make" value="Bajaj"/>
<property name="engineCC" value="150"/>    Here we are setting the same values for the two beans
</bean>

Solution::

<bean id="base" class="com.beans.Bike" abstract="true">
<property name="make" value="Bajaj"/>				----->Common Reusable properties..
<property name="engineCC" value="150"/>
</bean>

<bean id="pulsor1" class="com.beans.Bike" parent="base">
<property name="id" value="TS02222"/>  
</bean>

<bean id="pulsor1" class="com.beans.Bike" parent="base">
<property name="id" value="TS03333"/>
</bean>

Note:The abstract doesn't the bean class as the abstract but makes that configuration as the Abstract...We can't use that bean in the Client application....

Important Points:: Parent Bean configuration & child bean configuration can refer to the same class or the different classes..(Like Parent & Child physical classes)

Bean Inheritance using the Constructor:
---------------------------------------

	<bean id="baseCar" class="com.nt.beans.Car" abstract="true">
		<constructor-arg name="engineCC" value="1500" />
		<constructor-arg name="model" value="swift" />
		<constructor-arg name="company" value="suzuki" />
		<constructor-arg name="fuelType" value="diesle" />
		<constructor-arg name="owner" value="raja" />
		<!-- <constructor-arg name="type" value="hatchback" /> -->
		<constructor-arg name="type"><null/></constructor-arg>

	</bean>

	<bean id="rajaCar1" class="com.nt.beans.Car" parent="baseCar">
		<constructor-arg name="regNo" value="TS07EN4345" />
		<constructor-arg name="engineNo" value="12345" />
		<constructor-arg name="color" value="red" />
	</bean>

	<bean id="rajaCar2" class="com.nt.beans.Car" parent="baseCar">
		<constructor-arg name="regNo" value="TS07EN4344" />
		<constructor-arg name="engineNo" value="56789" />
		<constructor-arg name="color" value="white" />
		<constructor-arg name="owner" value="rani" />
	</bean>




RealtimeDI for the BeanInheritance: 
-----------------------------------

<!-- Configiure DataSource -->
	<bean id="oraDrds"	class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName"		value="oracle.jdbc.driver.OracleDriver" />
		<!-- <property name="url"			value="jdbc:oracle:thin:@localhost:1521:xe"  /> -->
		 <property name="username" value="system" />
		<property name="password" value="manager" /> 
	</bean>
	
	<bean id="oraScds"  class="org.springframework.jdbc.datasource.SingleConnectionDataSource"   parent="oraDrds"/>
	
	<bean id="oraHkDs"  class="com.zaxxer.hikari.HikariDataSource" parent="oraDrds">
	     <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:xe"/>
	     <property name="minimumIdle" value="10"/>   <!-- min pool size -->
	     <property name="maximumPoolSize" value="20"/>
	     <property name="connectionTimeout"  value="2000"/>
	</bean>
	
	<bean id="mysqlDrds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
		<property name="url" value="jdbc:mysql:///ntsp713db" />
		<property name="username" value="root" />
		<property name="password" value="root" />
	</bean>

	<!-- cfg DAO class -->
	<bean id="oraCustDAO" class="com.nt.dao.OracleCustomerDAOImpl">
		<!-- <constructor-arg ref="oraDrds" /> -->
		<!-- <constructor-arg ref="oraScds"/> -->
		 <constructor-arg  ref="oraHkDs"/>
	</bean>

	<bean id="mysqlCustDAO" class="com.nt.dao.MysqlCustomerDAOImpl">
		<constructor-arg ref="mysqlDrds" />
	</bean>



	<!-- cfg service class -->
	<bean id="custService"		class="com.nt.service.CustomerMgmtServiceImpl">
		<!-- <constructor-arg ref="mysqlCustDAO" /> -->
		<constructor-arg ref="oraCustDAO"/>
	</bean>

	<!-- cfg Controller class -->
	<bean id="controller" class="com.nt.controller.MainController">
		<constructor-arg ref="custService" />
	</bean>


								Collection Merging:
								------------------


It allows to merge the values set to the Base Bean configuration collection property with the values set to ChildBean Configuration collection property using the merge="true"

<bean id="base1stYear"  class="com.nt.beans.EnggCourse"  abstract="true">
         <property name="subjects">
              <list>
		<value>C</value><value>Maths</value>
	      </list>
	</property>

<bean id="ECE1styear"  class="com.nt.beans.EnggCourse"  parent="base1stYear">
        <property name="subjects">
              <list>
		<value>C</value><value>Digital Elctronics</value><value>Maths</value>
	      </list>
	</property>
<value>

Writing the common configurations again in the child bean configurations indicates the duplication..

Solution:

<bean id="ECE1styear"  class="com.nt.beans.EnggCourse"  parent="base1stYear">
        <property name="subjects">
              <list merge="true">
		<value>Digital Elctronics</value>
	      </list>
	</property>
<value>

1)Merging is possible only on the collection type property.. 
2) Base Bean configuration Collection type and child bean configuration collection type must match to perfom the merging


								Bean Alias:
								-----------

Alias name is nick-name or petname.. It is all about providing more alternative names/id's to use the bean.. Prior to spring 2.0 name attribute is given to provide the "alias name" from spring 2.0 <alias> tag is introduced for the same... We can use both the name attribute and <alias> tag to provide the alias name from Spring 2.0

<bean id="system" name="pc,desktop" class="com.nt.beans.Computer"/>
<alias name="system" alias="machine"/>
<alias name="system" alias="box"/>

<alias> tag is recommended to use because it allows to provide the alias names to multiple beans in the single place..Aliasing is useful in the maintenance mode of the bean configuration where we can short the alias name for the lengthy  bean ids..

factory.getBean("box") factory.getBean("pc") factory.getBean("system") factory.getBean("desktop")


Dependency LookUp:

If TargetClass wnats to use the dependent Object in all methods of the target class then we should use the Dependency Injection...

If the Target Class wants to use the dependent objects only inside the certain methods of target classes then use the Dependency Lookup..

Engine Dependent class need to be used only inside the move method of Vechile class..So we go for the Dependency Lookup code inside the move method of Vechile class..

If the Target Bean Class of Spring app wants to use the external services components gathered from the JNDI rgistry like getting the scoreComponent ref,getting the whether report component etc.. go for the dependency Lookup


public class Vechile {
	
	private String engineId;				//Bean Id is the String value
	
	public Vechile() {
		System.out.println("Vechicle class zero param constructor()");
	}
	
	public void setEngineId(String engineId) {
		this.engineId = engineId;
	}
	public String getEngineId() {
		return engineId;
	}
	

	public void move() {
		
		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);------>Factory is created Here and Factory will  also be created 											inside	TestClass
		reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		
		Engine engine = factory.getBean(getEngineId(),Engine.class);
		
		engine.start();
		
	}
}	

<bean id="engine" class="com.nt.beans.Engine" />
	<bean id="vechile" class="com.nt.beans.Vechile">
	<property name="engineId" value="engine"/>
	</bean>

Using the value attribute in above configuration beanId value will be passed directly without checking whether any such bean with Id exists or not.. To avoid that and perfom the intial check then we should use the <idref bean="engine"/>

<property name="engineId"><idref bean="engine"/>


								FactoryMethod:	
								--------------

The method that is capable of creatinng either the same class object or different class Object is called as Fcatory Method..

There are two types of Factory Methods:

Instance FActory Method:
-----------------------

String s1=new String("Hello");
String s2=s1.concat("123"); // hello 123 (returns the same class Object)

StringBuffer sb=new StringBuffer("Hello How are you?");
String s1=sb.substring(0,4);// Hello				Gives the different class Object


Static Factory Method:
----------------------

Class c=Class.forName("java.util.Date");(Returns the same class Object)
Console console=System.console();	(Returns the different class Object)

We can make the IOC conatiner to create the Spring Bean class Obect using the 4 ways:

1) Using the 0-param Constructor(When the no properties are configured for the dependency Injection and when only setter injection is enabled)
2) Using the parameterized constructor(When atleast one property is configured for the constructor injection)
3) Using the instance Fcatory method
4) Using the static factory Method

*****Servlet Conatiner,JSp Container can create the bean class Object by using the Zero Param Constructor..
*****But SpringContainer can create the SpringBeans objects in the above mentioned 4 ways..

***In Spring we can configure the Abstract Class as Spring Bean only when we enable the factory-method instantiantion

Static Factory Methods:
----------------------

<bean id="c1" class="java.lang.Class" factory-method="forName">  
<constructor-arg value="java.util.Date/"> "Not for the constructor injection this is given for passing the argument value to the forName method"
</bean>

<bean id="c2" class="java.util.Calendar" factory-method="getInstance"/>

Instance Factory Methods:
------------------------

<bean id="s1" class="java.lang.String">
<constructor-arg value="hello"/>		for the constructor injection
</bean>

<bean id="s2" factory-bean="s1" factory-method="concat">
<constructor-arg value="how are you?"
</bean>

<bean id="sb" class="java.lang.StringBuffer">
<constructor-arg value="hello how are you?"/>		
</bean>

<bean id="s3" factory-bean="sb" factory-method="substring">
<constructor-arg value="0"/>
<constructor-arg value="5"/>		
</bean>
 

SingleTon Java Class:
--------------------

The java class that allows us to create only one object per JVM is called as the Singleton class Java class

Take the singleton java class in the following situations:

If the class is not having any state..If class is having only sharable readonly state(static final varaibles)..If the class is having huge amount of data and perfoming the write operations on the state in the synchronized manner (1 thread at a time)

Instead of creating the multiple objects with the same data or no data, create one object and access it for multiple times for this take the class as the Singleton Java class

If we just create the for java class even thought the class allows us to create the multiple Objects then that class is not the singleton java class

Eg:: Our Servlet class is not Singleton class but it allows us to create the multiple Objects but it most of the times servlet container creates only one Object


Bean Scopes:
------------

Spring 1.x :: Singleton ProtoType

Spring 2.x:: Singleton ProtoType session request globalSession... globalSession scope is removed from the Spring 3.x

Singleton: Returns the same bean class Object for the factory.getBean() method calls with the same bean id..

ProtoType: Returns the seprate bean class Object for the every factory.getBean() method calls

Request: Bean class Object is specific to each request..

Session: Bean class Object is visible through out the session

Scope attribute of the <bean > tag specifies the bean scope..

Cache: It is the temporary memory that holds the data for the temporary period[Buffer]...If the DAO class uses the cache support it maintains the database data like Countries info and uses them across the multiple same request and reduce the no:of hits to the database software..

Are the Cache & Session meant to hold the same kind of the data? NO.. Sessions store the client information where as the Cache's stores the Buffered data that needs to be accessed acrosss the multiple same requests..


** Note: The Bean scope singleton never makes our bean class as the Singleton java class...But gives the singleton behaviour while creating the Object..

IF bean scope is Singleton then the IOC container creates the bean class Object and keeps in HashMap object element as the value by having the bean 'id' as the key and uses that Object across the multiple factory.getBean() method calls..

If the bean scope is ProtoType then the IOC container doesn't keep the created bean class Object in the HashMap so it returns the new Object for every factory.getBean() call

If the scope is "request" then the bean Object will be maintained as the request attribute..If the scope is "Session" then bean object will be maintained as the session attribute..


Bean Wiring:
------------

Configuring the beans and their dependency injection in the Spring Bean configuration file is called as the Wiring..

Explicit Wiring: Here we use the <property>,<constructor-args> for the dependency injection configuration

AutoWiring: Here IOC container automatically detects the dependents and injects then to the target Objects..Here no <property> <constructor-args> are required..


AutoWiring/Implicit Wiring Limitations:
--------------------------------------

Can be used as only to to inject Objects but not the simple values...If the IOC container has multiple dependencies to inject then ambiguity problem may raise.. Kills the readability of the xmlfile, so the bug fixing becomes much complex.

By using the autowire attribute of the bean tag we can enable the autowiring.. There are 4 modes of perfoming the autowiring

1)ByName 2)ByType 3)constructor 4)autodetect

autowire="byName"
---------------
Perfoms the setter injection.. For all the target class property names & dependent class bean id must match..There is no possibility of getting the ambiguity problem..

autoWire="byType"
----------------
*Perfoms the setter injectiom...For this target class property type and dependent class type must be match or must be compatabile with each other..There is possibility of getting the ambiguity problem..


autoWire="constructor"
---------------------

Uses the parameterized constructor to perfom the constructor injection..There is possibility of getting the ambiguity probelm if multiple depdendenices are found, but it doesn't throw the exception if the target class 0-param constructor otherwise the exception will be thrown..

<bean id="travelAgent" class="com.nt.beans.TravelAgent" autowire="constructor"> First it tries to do the byName type autowiring otherwise it looks for the byType..

public void setTourPlan(TourPlan tourPlan) {		For the autowiring using the byName the Bean Should match the tourPlan
		System.out.println("Travel Agent setTourPlan()");
		this.tourPlan = tourPlan;
	}
					AutoWire By Constructor
public TravelAgent(TourPlan plan) {   **The beanName should map to the varaible name.. Then it perfoms the ByName mode of Injection
		System.out.println("Travel Agent 1 Param Constructor");
		this.tourPlan=plan;	** If the names doesn't match then it tries to perfom the byType.If multiple dependencies found and zero param 
	}				constructor is found.. It just creates the empty object without throwing the exception.If zero param constructor is 
					also not found then it throws NoUniqueBeanDefFound Exception..


	<bean id="travelAgent" class="com.nt.beans.TravelAgent" autowire="constructor">
		  <!-- <property name="tourPlan"  ref="tourPlan"/>  -->
	</bean>
 	<bean id="tourPlan" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir</value>
 			<value>Araku</value>
 		</array>
 		</property>
 	</bean>
 	
 	<bean id="tourPlan1" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir1</value>
 			<value>Araku1</value>
 		</array>
 		</property>
 	</bean>

------------------------------------------------------------------------------------------------------------------------------------------------------------

What happen if targetclass is having the  multiple constructors..And we are depending on the constructor mode of injection

public TravelAgent() {
		System.out.println("Zero Param constructor Tourplan");
	}
	 
	public TravelAgent(TourPlan tourPlan) {
		System.out.println("Travel Agent 1 Param Constructor");
		this.tourPlan=tourPlan;
	}
		Look forbyName if no byType   Look forbyName if no byType
	public TravelAgent(TourPlan tourPlan,TourPlan tourPlan1) {
		System.out.println("Travel Agent 2 Param Constructor");		It always does the constrcutor injection on the hghest constructors
		this.tourPlan=tourPlan;
		this.tourPlan1=tourPlan1;
	}

Lets say we have only one tourPlan.. Then first constructor-arg type is byName and second constr-arg type is (byName not satisfied it looks for the byType)
satisfied so it injects that object into the TargetClass

bean id="tourPlan" class="com.nt.beans.TourPlan">
 		<property name="places">
 		<array>
 			<value>JammuKashmir</value>
 			<value>Araku</value>
 		</array>
 		</property>
 	</bean>
 	

autowire="autodetect":
---------------------

Autowiring by autodetect uses two modes, i.e.constructor or byType modes. First, it will look for valid constructor with arguments. If it is found, then the constructor mode is chosen. If there is no constructor defined in a bean, the autowire byType mode is chosen... Removed from spring 3.0 onwards..

autowire="no" Disables the autowiring

What happens if we enable the both autowiring and explicit wiring on the same bean property?

if both wirings are perfoming in the same constructor injection or the same setter injection then the explicit wiring value will be injected as the final values..if both the wirings are perfoming two different types of injections then the setter injection values will injected as the final value..

Can we apply the @AutoWired annotation on the multiple constructors?

							Dependency Check-:
							------------------

while perfoming the constructor injection by using the certain parameterized constructor,all the params for the constructor need to be configured for wiring
if not configured then exception will be thrown

The above restriction is not there for the setter injection configuration..to enable such restriction while working with setter injection go for the depdency-check attribute in the bean tag..

dependency-check="simple" dependency-check="objects" dependency-check="all" dependency-check="none"


Note: dependency-check is removed from the Spring 2.5 because it applies the resttriction on the group of properties not on the specified properties..
Required is given as the alternative..


Nested Bean Factory:
--------------------

In realtime project contains multiple layers..instead of configuring all the beans inside one IOC container it is recommended to take multiple IOC containers on one per layer basis...To use the beans of one IOC conatiner inside the another IOC container it is recommended to make them as the Nested IOC conatiners like the parent & child containers..

The beans of the parent container can be used in the child container but the reverse is not possibel.. In the parent container we configure the persistence layer beans so it can be used in the child container where usually service layer beans are configured...

While working with nested bean factory SpringBean file associated with the Child container is called as the ChildConfiguration file and config-file associated with the parent conatiner is called as the Parent configuration file

Can you explain various attributes of the Spring <ref> tag?

<ref local="beanid"/> locates the bean id based Spring Bean configuration from the current/local spring beans configuration file..

<ref parent="beanid"/> locates the bean id based Spring Bean configuration from the parent Spring bean Configuration file...

<ref bean="beanId"/> First looks in the current/local/Child Configuration file if not found then it looks in the Parent Configuration file..

<property name="details">
	<ref bean="id"/>
</property>

	(OR)

<constructor-arg name="details">
	<ref bean="id"/>
<constructor-arg>

<property name="details" ref=""> is equals to the  <property name="details"><ref bean="id"/></property>


Parent Configuration file:

<bean id="loanDetails" class="com.nt.beans.LoanDetails">
	<property name="loanId" value="1234"></property>
	<property name="loanType" value="BankLoan"></property>
	<property name="customer" value="Muni"></property>
</bean>
	

Child Configuration file:

<bean id="approver" class="com.nt.beans.BankLoanApprover">
	<!-- <property name="details">
	<ref parent="loanDetails"/> These configuation is not working why? Need to check
	</property> -->
	<property name="details" ref="loanDetails"/>
</bean>


		///IOCProj24-NestedBeanFactory/src/main/java/com/cfg/loan-beans.xml
		BeanFactory pfactory=new XmlBeanFactory(
				new FileSystemResource("src/main/java/com/cfg/loan-beans.xml"));
		BeanFactory cfactory=new XmlBeanFactory(
				new FileSystemResource("src/main/java/com/cfg/approval-beans.xml"),pfactory);
		
		BankLoanApprover approver = cfactory.getBean("approver", BankLoanApprover.class);
		
		System.out.println(approver);

		DefaultListableBeanFactory pfactory1 = new DefaultListableBeanFactory();
		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(pfactory1);
		reader.loadBeanDefinitions(new FileSystemResource("src/main/java/com/cfg/loan-beans.xml"));
		
		DefaultListableBeanFactory cfactory1 = new DefaultListableBeanFactory(pfactory1);
		XmlBeanDefinitionReader reader1 = new XmlBeanDefinitionReader(pfactory1);
		reader1.loadBeanDefinitions(new FileSystemResource("src/main/java/com/cfg/approval-beans.xml"));
		
		BankLoanApprover approver2 = cfactory1.getBean("approver", BankLoanApprover.class);
		
		System.out.println(approver2);
		//As we are creating the two different containers then the BankLoanApprover Object is created inside the 
		//both containers
		
		System.out.println(approver.hashCode()==approver2.hashCode());

-----------------------JDBC Sample Code----------------------------------------------------------------	
st=con.createStatement();
rst=st.executeQuery(""SELECT Query");
int rows=stmt.executeUpdate(sql);

ps=con.prepareStatement(INSERT_SQL);
int rows=ps.executeUpdate();

pstmt = con.prepareStatement(selectQuery);
rst = pstmt.executeQuery();

----------------------Copying the DTO's to VO's------------------------------------------------------------
		List<EmployeeVO> listDTO=new ArrayList<EmployeeVO>();
		listDTO=service.searchEmpsByDesg(desgs);		
		//copy listDTO to listVO
		listDTO.forEach(dto->{
			 EmployeeVO vo=new EmployeeVO();
			 vo.setSno(String.valueOf(dto.getSno()));		----->Sample Code for collections copying to the other collection
			 vo.setEno(String.valueOf(dto.getEno()));
			 vo.setEname(dto.getEname());				--->Here the dataTypes used in the DTO classes and types used int VO 
			 vo.setJob(dto.getJob());				   class is different so we are manually doing the work
			vo.setSalary(String.valueOf(dto.getSalary()));		   but it is not same with the BeanUtils class.....
			vo.setDeptno(String.valueOf(dto.getDeptno()));
			listVO.add(vo);
		});
		

List<EmployeeBO> listBO=dao.findEmpsByDesg(cond);
List<EmployeeDTO> listDTO=new ArrayList<EmployeeDTO>();
//Convert ListBO to  ListDTO							--->Easy Code(Enhanced For Loop)
		for(EmployeeBO bo:listBO){
			 EmployeeDTO dto=new EmployeeDTO();
			 BeanUtils.copyProperties(bo,dto);  Into the common properties data will be copied!! 
			 dto.setSno(listDTO.size()+1);	    Into the specific properties we need to do copy manually	
			 listDTO.add(dto);
		}


/*listBO.forEach(bo->{
			EmployeeDTO dto=new EmployeeDTO();
			BeanUtils.copyProperties(bo,dto);
			dto.setSno(listDTO.size()+1);
			listDTO.add(dto);
		});*/


Working with ApplicatioContext Container:
-----------------------------------------

Bean Factory container means its an IOC conatiner that is created by the BeanFactory Object

ApplicationContext container means its an IOC conatiner that is created by the ApplicationContext Object..

ApplicationContext Object is the Object of javaclass that implements the ApplicationContext(I):

There are 3 implementations:  FileSystemXmlApplicationContext  ClassPathXmlApplicationContext XmlWebApplicationContext

FileSystemXmlApplicationContext:
Creates the applicationContext Object by locating the springbean configuration file from the directories of Application

ClassPathXmlApplicationContext:
Creates the applicationContext Object by locating the springbean configuration file from the directories and jar files added to the classpath of Application

XmlWebApplicationContext:
Creates the applicationContext container Object inside the WebApplications..

ApplicationContextContainer can perfom all the operations of the BeanFactoryContainer as well as the extra operations also:
----------------------------------------------------------------------------------------------------------------------------

1)PreInstallation of SpringBeans 2)Ability to work with Properties file 3)Support for the internatiolization 4)Support for event handling/processing etc..

While working with BeanFcatory container the container instantiates the beans(of any scope singleton/prototype) only when the factory.getBean() method is called but when the ApplicationContext conatiner is used all the singletonscoped beans will be pre-instantiated that means at moment when the conatiner is started.. This is called the pre-instantiation of the singleton beans..

If the prototype scoped bean is the dependent to the singleton scoped bean then the prototype scoped bean will also be pre-instatiated to support the dependency injection on the singleton scoped bean..but it doesn't mean the prototype scoped bean has changed it's behaviour changed to singleton****

Bean-Preinstantiaon is much similar to the <load-on-startup> on servlet..

JDBC datasource object represents the jdbc managed connection pool..we can use the jdbc datasource object to get connection object from the jdbc connection pool..DriverManagerDataSource gives the datasource object pointing to the IOC container managed jdbc connection pool.


Nested Application Context Example: Using multiple containers for multiple Layers:
---------------------------------------------------------------------------------
ApplicationContext pContext = 
			new ClassPathXmlApplicationContext("com/cfg/business-beans.xml");
	
ApplicationContext cContext = 
			new ClassPathXmlApplicationContext(new String[]{"com/nt/cfgs/presentation-beans.xml"},pContext);
		
EmployeeSearchController controller = cContext.getBean("empController", EmployeeSearchController.class);

Pre-instantion on the beans can be disabled using the lazy-int attribute in the bean tag:
-----------------------------------------------------------------------------------------
<!-- Dependent Beans -->
  <bean id="dtdc"  class="com.nt.beans.DTDC" scope="prototype"/>
  <bean id="bDart"  class="com.nt.beans.BlueDart"  lazy-init="true"/>
  <bean id="fFlight"  class="com.nt.beans.FirstFlight" scope="singleton" lazy-init="true"/>
  
  <!-- Main Bean/Target Bean -->
  <bean id="fpkt"  class="com.nt.beans.Flipkart" lazy-init="true"> If it is not set to true then all dependent Beans Objects will be pre-created
     <property name="courier"  ref="fFlight"/>
  </bean>


Working with Properties file:
-----------------------------

The javabean whose object holds the data required for the persistence logic or data generated by the persistence logic is called as the BO logic..

The text file that maintains the entries as the key value pairs is called as the Properties file..We generally use the properties file to mainatain the jdbc 
properties like DriverClassName,URL,USERNAME,PASSWORD and make them flexible to modify without touching the source code..

If the SpringF/W is added to the existing application and if existing project are using the properties file to get the data from the properties file to get the jdbc data then SpringF/w should be capable to fetch the data from the properties file..

The text file that maintains the entries as the key value pairs is called Properties file.. In ApplicationContext container environment we need to configure the PropertyPlaceHolderConfigurer class as the SpringBean to make the container to locate the properties file and recognize the place holders in SpringBean configuration file.. Place holders should be in the format that will be understandable by the Spring..

PlaceHolder: ${}.. Each PlaceHolder represents the 1 key of the property file to get the value from the properties file..

Need to configure the special Spring Bean to work with the properties files:Only ApplicationContext has capability to recognise this spring bean

 <bean
	class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations">
		<list>
			<value>com/nt/commons/jdbc1.properties</value>
			<value>com/nt/commons/jdbc.properties</value>
		</list>
	</property>
</bean>

Need to take the placeHolders inside the spring bean configuration file.. PropertyPlaceholderConfigurer loads properties from the properties files that are configured & then replaces the placeholders before the springbean configuration file is read from the ApplicationContext container...

<bean id="drds"   class="org.springframework.jdbc.datasource.DriverManagerDataSource">
     <property name="driverClassName" value="${jdbc.driver}"/>
     <property name="url" value="${jdbc.url}"/>
     <property name="username" value="${jdbc.user}"/>
     <property name="password" value="${jdbc.pwd}"/>
 </bean>


		pCtx=new ClassPathXmlApplicationContext("com/cfg/business-beans.xml");
		cCtx=new ClassPathXmlApplicationContext(new String[]{"com/cfg/presentation-beans.xml"},pCtx);
		//get Bean (Controller)
		controller=cCtx.getBean("empController",EmployeeSearchController.class);

No extra configurations required for the ApplicationContext container.. the PropertyPlaceHolder bean is automatically recognised..

For the XMLBeanFactory we need to configure the PropertyPlaceHolderConfigurer..

		XmlBeanFactory pfactory = new XmlBeanFactory(new ClassPathResource("com/cfg/business-beans.xml"));
		BeanFactoryPostProcessor bfpp = pfactory.getBean("ppc",PropertyPlaceholderConfigurer.class);
		bfpp.postProcessBeanFactory((ConfigurableListableBeanFactory)pfactory);
		
		XmlBeanFactory cfactory=new XmlBeanFactory(new ClassPathResource("com/cfg/presentation-beans.xml"),pfactory);
		controller=cfactory.getBean("empController",EmployeeSearchController.class);


Core Java Internatilization:
---------------------------

Locale Means (Country+Language)::

en-us en-Br fr-FR hi-IN(English as it is spoken in the Britan)

Making our application working for the different locales is called as the enabling the Internationalzation..It deals with displaying the Presentation labels

displaying the numbers.. In JEE application we work with ResourceBundle, LocalClass of java.util package to work with the I18N..

To apply the I18N we need to take the multiple properties file having the presentation labels on 1 per locale basis.. All these files must have the same keys & different values..

Eg:: app.properties(Base File) app_de_DE.properties(German) etc..

If no matching file is found the base file will be automatically used..

We can use the GoogleTranslator labels in other language based on the given English word..We can also place the Unicode numbers in properties file to render the non english characters..For that we need to use the third party tools like Unicode editor and jdk native2ascii tool

Use the website:https://r12a.github.io/app-conversion/..Copy the Hindicharacters(from Google Translator) (or) Spanish Words(from Tanslators) and convert into the Unicode characters.. and need to place them in the properties file against the value..save the file by taking the "unicode" as encoding type..

Use the JDK tool native2Ascii to get the unicode numbers... native2Ascii -encoding unicode inputfile outputfile..

native2ascii -encoding unicode C:\Users\91970\Desktop\Bangla.txt C:\Users\91970\Desktop\output.txt

In the webapplication if multiple servlet/jsp programs wants to display the Labels collected from the properties file then we need to create the ResourceBunlde class Object in the multiple servelt & jsp programms or we need to place the ResourceBundle class object inthe request scope as attribute

If we want to display the values of same key belonging to multiple locale properties files then we need to create the multiple ResourceBundle Objects..

ResourceBundle Object per Locale/properties file..We can overcome the problem in Spring environment by using the Application Context Container with the support of the ResourceBundleMessageSource class.. 

I18N:
----

Only ApplicationContext container supports the I18N.We can use the ResourceBundleMessageSource class as the spring bean by specifying the base property file name as the value of "baseName" property.

Since we configure the above class as the singleton scope SpringBean then that container will create one object and uses it for multiple times..But the above bean must be configured with fixed beanId "messageSource".. We can call the getMessage() to make the container to locate the proerties file based on the locale Object data that we pass with support of bean confgured with Beanid "messageSource".

Advantage: Just by using the One ResourceBundleMessageSource Object we can use the properties file in multiple locations..Allows to read the same message in different languages with one object of the above class..

		Locale locale=new Locale(args[0], args[1]);
		
		ResourceBundle bundle = ResourceBundle.getBundle("com/nt/commons/App",locale);
		
		System.out.println(bundle.getString("btn1.cap"));
		System.out.println(bundle.getString("btn2.cap"));
		System.out.println(bundle.getString("btn3.cap"));
		System.out.println(bundle.getString("btn4.cap"));


SpringAPP:

 <!-- ResourceBundleMessageSource class  cfg as spring bean having fixed bean id -->
    <bean id="messageSource"   class="org.springframework.context.support.ResourceBundleMessageSource">
         <property name="basename"  value="com/nt/commons/App"/>
    </bean>
    <!-- We are working with multiple properties file so not required to worry about configuration of the
    	 PropertyPlaceHolderConfigurer ResourceBundleMessageSource takes care-->
		
		ctx=new FileSystemXmlApplicationContext("src\\main\\java\\com\\cfg\\applicationContext.xml");
		//prepare Locale object
		locale=new  Locale(args[0],args[1]); //args[0] ->language  , args[1] -> country
		//get Messages
		cap1=ctx.getMessage("btn1.cap", new String[] {"student"} ,"msg1", locale);
		cap2=ctx.getMessage("btn2.cap", null, "msg2",locale);
		cap3=ctx.getMessage("btn3.cap", null, "msg3",locale);
		cap4=ctx.getMessage("btn4.cap", null,"msg4", locale);
		System.out.println(cap1+"   "+cap2+"   "+cap3+"   "+cap4);
		System.out.println(ctx.getMessage("btn2.cap", new String[] {" message"," Test"}, new Locale("de","DE"))); prints://aktualisieren message Tst
		System.out.println(ctx.getMessage("btn2.cap", null, new Locale("hi","IN")));
		System.out.println(ctx.getMessage("btn2.cap", null, new Locale("x","y")));

FallBackProperties File:
-----------------------
btn1.cap=insert
btn2.cap=update
btn3.cap=delete
btn4.cap=view

App_de_DE.properties:
---------------------

btn1.cap=einfgen{0}
btn2.cap=aktualisieren{0}{1}
btn3.cap=lschen
btn4.cap=Aussicht

Event Handling:
---------------
Event is the Object/action that is raised on the component/Object..Event Handling means executing the logic when the event is raised for this we need the support of EventListeners..

There are four actors in the event processing/Handling:
------------------------------------------------------

Source Object(Button) EventClass(ActionEvent) EventListener(ActionListener) EventHandling Method ( actionPerfomance(--))

We can perfom eventHandling on ApplicationContext container to keep track of when the container is created/started  or Stopped.This allows programmer to evaluate the perfomance of Spring code/logic

Source Object: ApplicationContext EventClass: ApplicationEvent ListenerClass: ApplicationListener EventHandling Method:onApplicationEvent() executes when the applicationContainer is started or stopped

Example App: Create the Class for event Handling implementing the ApplicationListener..Configure the Listener as the SpringBean.. Create the ApplicationContextContainer and stop the container inside the Java Application

<bean class="com.nt.listener.IOCContainerMonitoringListener"/>

public class IOCContainerMonitoringListener implements ApplicationListener<ApplicationEvent> {
     private long start,end;
     
     public IOCContainerMonitoringListener() {
		System.out.println("Listener:: 0-param constructor");
	}
     
	@Override
	public void onApplicationEvent(ApplicationEvent e) {
		if(e.toString().indexOf("ContextRefreshed")!=-1) {
			start=System.currentTimeMillis();
			System.out.println("IOC contaier is started at::"+new Date());
		}
		else if(e.toString().indexOf("ContextClosed")!=-1) {
			end=System.currentTimeMillis();
			System.out.println("IOC contaier is stopped/closed at::"+new Date());
			System.out.println("IOC container active duration ::"+(end-start)+" ms");
		}

	}
}


When to use the BeanFactory & Application Context Containers:?

If we are developing the small applications or embedded system applications having the support of the Spring then use the BeanFactory(Here few extra kb also matters..)If we are developing the enterprise applications(like distributed or web applications) then ApplicationContext is Prefrabble..


Operation of Container 						Bean Factory				ApplicatonContext

Bean Instantiation							yes					yes
Bean Wiring								yes					yes
AutoWiring								yes					yes
Properties file support							no					yes
I18N									no					yes
EventHandling								no					yes
Automatic Registration BeanPostProcessor				no					yes
Automatic Registration BeanPreProcessor					no					yes
Stopping/Closing Container 						no					yes

Spring Bean LifeCycle:
--------------------

It talks about the Springbean class Object creation to destruction..In the servlet life cycle we use the following lifecycle methods..

int() service() destroy()

in ordinary classes we use the constructor finalize methods to place the intialization and unintialization logics..

Springbean allows to lifecycle methods..

init() Method: Executes after all dependencies are injected.. so can be used to verify whether injection are done properly or not with appropriate value

Destroy() Method: Executes when the IOC container is about to destroy the bean class Object.. Useful to place the unintialization logics..

In Spring we can perfom the Spring LifeCycle operations in 3 ways:
----------------------------------------------------------------

1) Declrative Approach 2) Programmatic Approach  3) Annotation Approach

Declrative: Allows to configure the user defined methods as the bean lifecyle methods..These methods are called custominit or customdestroy methods..These methods return type should be void and shouldn't contain the parameters..

We must configure the above methods as the LifeCycle methods using the init-method and destroy-method attributes of the <bean> tag

<bean id="cve"  class="com.nt.beans.CheckVotingElgibility"  init-method="myInit"  destroy-method="myDestroy" >
     <property name="name"  value="raja"/> 
    <property name="age"  value="20"/>
    <property name="addrs"  value="hyd"/>


	factory=new DefaultListableBeanFactory();
	reader=new XmlBeanDefinitionReader(factory);
	reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
	//get Bean
	voting=factory.getBean("cve",CheckVotingElgibility.class);
	//invoke b.method
	System.out.println(voting.checkVotingElgibility());
	//factory.destroySingletons();
	factory.destroySingleton("cve");

Using the ApplicationContextContainer we can close the container or stop the container

		ctx=new ClassPathXmlApplicationContext("com/cfg/applicationContext.xml");
		//get Bean
		voting=ctx.getBean("cve",CheckVotingElgibility.class);
		//invoke b.method
		System.out.println(voting.checkVotingElgibility());

		//close container
		//((AbstractApplicationContext) ctx).close();
		((AbstractApplicationContext) ctx).stop();
		voting1=ctx.getBean("cve",CheckVotingElgibility.class); throws: illegstateException if we uncomment close method..with stop method we don't 										get
	       System.out.println(voting.hashCode()+" "+voting1.hashCode());


In the customInit methods we don't write the intialization logic because it won't execute after Bean INstantiation it executes after completing all the injections..While working with ApplicationContext conatiner we close the container by calling the close method..The container destroys all the bean classes Objects when this tasks is about to happen customdestroy/destroy method will be called.While working with BeanFactory container we can use the factory.destroySingletons() method to destroy all the singleton scoped beans..

Limitations of declarative Approach:
-------------------------------------

If you forget to configure the lifecycle method in xml file they will not be executed..Identifying the lifecycle method is complex while dealing with predefined or thirdparty supplied classes as the Spring beans..

In programatic approach Springbean class must implement IntializationBean or DisposableBean(I) given by the Spring API(Bean classes becomes API dependent)

@Override
public void afterPropertiesSet() throws Exception {} Alternative to customInit method..

@Override
public void destroy() throws Exception {} Alternative to the destroy method..

If we configure the both the Declrative and programmatic approach:Execution order

CVE:afterPropertiesSet(-) method
CVE:myInit()
CVE:checkVotingElgibility()
Mr/Miss/Mrs.raja u r elgible for voting
CVE:destroy()
CVE:myDestroy()

Recommended to use only one approach..Programmatic approach makes our Spring bean classes as the Spring API dependent.. Most of the Spring supplied classes are given based on the programmatic approach of bean life cycle.

Bean LifeCycle Annotation Approach:
----------------------------------

When we annotate a method in Spring Bean with @PostConstruct annotation, it gets executed after the spring bean is initialized.

We can have only one method annotated with @PostConstruct annotation. This annotation is part of Common Annotations API and its part of JDK module javax.annotation-api. So if you are using this annotation in Java 9 or above, you will have to explicitly add this jar to your project. If you are using maven, then below dependency should be added to it.

<dependency>
	<groupId>javax.annotation</groupId>
	<artifactId>javax.annotation-api</artifactId>  @PreConstruct & @PostDestroy Annotation's
	<version>1.3.2</version>
</dependency>


When we annotate a Spring Bean method with PreDestroy annotation, it gets called when bean instance is getting removed from the context. This is a very important point to understand  if your spring bean scope is prototype then its not completely managed by the spring container and PreDestroy method wont get called.

If there is a method named shutdown or close then spring container will try to automatically configure them as callback methods when bean is being destroyed.

Example::

		<dependency>
			<groupId>javax.inject</groupId>			Annotations like @Named will come
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>


<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd 
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context.xsd">
    
 	<!-- Bean defined and dependents are defined using the Annotations -->

	<context:component-scan base-package="com.nt.beans"></context:component-scan>  BeanFactory/DefaultListableBeanFactory cannot recognise this..
</beans>

@Named("cve")
@Scope("singleton")
public class CheckVotingElgibility{
	
	@Value("Muneendar")
	private String name;
	
	@Value("Hyderabadi")
	private String addrs;
	
	@Value("20")
	private int age;
	
	public CheckVotingElgibility() {
		System.out.println("CVE:0-param constructor");
	}

@PostConstruct
	public void myInit(){
		System.out.println("CVE:myInit()");
		if(name==null || age<=0)
			throw new IllegalArgumentException("provide valid inputs");
	}

@PreDestroy
	public void myDestroy(){
		System.out.println("CVE:myDestroy()");
		name=null;
		age=0;
		addrs=null;
	}


						Aware Injection/Interface Injection/Contextual Depedency Lookup:
						--------------------------------------------------------------
If the underlying container assigns or injects the values or objects to target class only when it implements/extends certain interface/class is called as the contextual dependency lookup..

Ex:ServletContainer assigns the config object to our servlet class only when the servlet class implements the javax.servlet.Servlet directly or indirectly...


If one class needs the another class then we go for the depedencylookup/dependencyinjection..If target class wnats to use the dependent object in all the methods of the target class then we should go for the dependency injection..If target class wants to use the dependent object only in the specific methods then we should go for the dependency lookup..

If we perfom the dependency lookup in the regular fashion we need to create the one more IOC container in the target class to get the Dependent object..
so instead of creating the seprate IOC container to inject the BeanFactory/Application Context object by implementing the BeanFactoryAware...The underlying container is injecting the Object/value only when the target class implements the XXXAware interface. So it is called the AwareInjection/Interface injection
or contextual dependency lookup..

XXXAware Interfaces are::

BeanNameAware --->To inject the current beanid
BeanFactoryAware-->To inject the BeanFactory Object
ApplicationContextAware-->To inject the ApplicationContext Object


The IOC conatiner created by the BeanFactoryObject  internally maintains the beanId's..The IOC conatiner created by the ApplicationContextObject  internally maintains beanId's ApplicationContext Object BeanFactoryObject etc..

public class Viechle implements ApplicationContextAware {
	
	private String beanId;
	private ApplicationContext ctx;
	
	static{
		System.out.println("Viechle:static block");
	}
	
	public Viechle() {
		System.out.println("Viechle:0-param constructor");
	}

	public void setBeanId(String beanId) {
		System.out.println("setBeanId(-)");
		this.beanId = beanId;
	}
	
	@Override
	public void setApplicationContext(ApplicationContext ctx) throws BeansException {
		System.out.println("setApplicationContext(-)");
		this.ctx=ctx;
	}
}


ApplicationContext ctx=new ClassPathXmlApplicationContext("com/cfg/applicationContext.xml"); As soon as the ApplicationContext Object is created then the Vechicle class Objected is craeted and ApplicationContext Object is injected into the class..

Viechle:static block
Viechle:0-param constructor
setBeanId(-)
setApplicationContext(-)


Problem with LookUp Method Injection:
------------------------------------
<bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton">
       <property name="handler"  ref="rh"/>
   </bean>

When the protoType scoped bean is dependent to the Singleton scoped bean then somehow prototype scoped bean also acts as the SingletonScoped Bean..

Eg: All requests coming to the WebApplications will be handled by the Single ServletContainer/WebContainer..This container should be using the seprate request handler to process each request..So, Servlet Container is target class and RequestHandler should be taken as the dependent class and moreover the servlet container should be taken as the Singleton scoped bean and request handler should be taken as the prototype scoped bean..But because of above problem "RequestHandler" also acts as the Singleton Scoped bean 

TargetClass Bean Scope                 DependentClass Bean Scope      ResultantScope of DependantBean
----------------------------------------------------------------------------------------------------------
Prototype				Singleton			Singleton

Singleton				Singleton			Singleton

Prototype				Prototype			Prototype

Singleton				Prototype			Singleton(Use the dependency lookup or LookUp Method)


We Shouldn't think of dependency injection(constructor/setter) in the following situations:

If the dependent bean is required for the Target BEan only in the specific methods if the target bean scope is singleton and dependent bean scope is prototype in the above situation we should prefer for the dependencyLookup.If we go for the traditonal depdency lookup we should go for the extra IOC container in the methods of the target class.(Which is Bad Practisce).. By using the Aware Injection we can avoid the extra IOC container in the above methods of the Target class..But it kills the NonInvasive behaviour of the Spring APP because the target bean should implement xxxAware injection


To overcome the above two problems we can use the dependency Lookup method Injection which "perfoms the dependency lookup" but container should write the code for it(not the programmer)

To perfom the Lookup method Injection the in TargetClass we should consider the below points:
--------------------------------------------------------------------------------------------

Target Bean class should have the abstracted method returining the dependant bean class Object(For this target class should be taken as Abstract C/Interface 

We must configure the above abstract methods with targetBean class by using the <lookup-method> tag..

Note:: We can configure the abstract class as the Spring Bean only when the <lookup-method> tag is placed for lookup method injection otherwise not possible

Spring IOC container generates the subclass for the targetBean class & implements the abstract method that class to get & return the dependent bean class Object.. For this it internally uses the CGLIB. In Spring 2.x 3.x we need to separately supply CGLIB where as in Spring 4.x not required..

Lookup Method Injection(Usecase):

ServletContainer(Singleton)<----------------->RequestHandler(ProtoType)
Manager(Singleton)<----------------------------->Customer(ProtoType)
LoanApprover(Singleton)<------------------------>LoanDetails(Prototype)

Lookup Method Injection Solutions: Using the Tradiotional Lookup Operation.. Using the AwareInjection+DL...

LMIFinalSolution

<bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton" >
      <lookup-method name="getRequestHandler" bean="rh" /> 
   </bean>

public abstract class WebContainer {
	
	public abstract RequestHandler getRequestHandler();
	
	public WebContainer() {
		System.out.println("WebContainer :: 0-param constructor");
	}
	
	public void  delegateRequest(String data){
		RequestHandler handler=null;
		System.out.println("WebContianer: request recived with "+data+" and delegating to handler");
		//create IOC container
		//get Depedent Bean obj
		handler=getRequestHandler();
		handler.proessingRequest(data);
	}
	
}//class



Using the Java8 the Target Class can also be the interface:
------------------------------------------------------------

public interface WebContainer {
	
	public  RequestHandler getRequestHandler();

//Only one implementation class is created but this method is called onDemand whenever this bean is needed and new
//Object is returned always
	
	default void  delegateRequest(String data){
		RequestHandler handler=null;
		System.out.println("WebContianer: request recived with "+data+" adn delegating to handler");
		//create IOC container
		//get Depedent Bean obj
		handler=getRequestHandler();
		handler.proessingRequest(data);
	}
	
}//class


 <bean id="rh"  class="com.nt.beans.RequestHandler"  scope="prototype"/>
   
   <bean id="container"  class="com.nt.beans.WebContainer" scope="singleton" >
      <lookup-method name="getRequestHandler" bean="rh" /> 
   </bean>


FactoryBean:
----------

The class that is capable of creating and returing Objects is called Factory Class..In Spring FactoryBean is selfless bean it doesn't give its own object, but it always give one resultant object..

To develop class as the FcatoryBean Class must implement SpringAPI's FactoryBean(I) and should provide definition for the Three methods:

getObject() -->creates and returns resultant Object 
getObjectType()--->returns java.lang.Class object holding the resultant Object class name
IsSingleton()--->Specifies whether resultant Object should be taken as singleton Object(true) or prototype Object(false)


The bean that gets Objects from the JNDIRegistry based on given JNDI name will be developed as the FactoryBean

Factory using the ServiceLocator: instancefactory staticFactory method FactoryBean implementation.. 

MethodReplacement:
-------------------
In the normal classes if you want to replace the existing logic of business method with new logics we have 2 options:

1) Comment the existing logics and write the new business logic in the Same business method
2) Devlop the subclass and override the business method with the new logics..

In the above model we need to modify the source code to revert back to the original logics if we write new logics on expermental basis or the new logics execution has failed in the production environment at the client side..The another problem with the above approach is reverting back to the original logics is comlaex when the source code is not exposed...

To excute the new logic when the offer period is there and revert back to the orginal logics once the offer is over without touching the source code we can't use the above models..

To overcome the above problem we use the "MethodReplacemet" concept of Spring..For this we need to develop the seprate Class implementing the MethodReplacer (I) and need to write the new logics inside the reImplement() method..

public Object reimplement(Object obj,Method method,Object[] args): 

Object obj: Gives the access to the original bean class obect.. Method method: gives the access to the orginal method that we wanted to replace.

Object[] args: Gives access to the orginal method args..


We need to configure the MethodReplacer class as the Spring Bean and we need the IOC conatiner to execute the reimplement() When the original method is called.  <replaced-method name="original method name" replacer="BeanId method replacer class"/>

When the ctx.getBean(-) is called then the container checks whether the <replaced-method> tag is configured or not in the inmemory metadata of xml file. If configured then container generates the inMemory proxy class and returns that Object..If not configured it creates the bean Class Object and retruns that Object..

public  class IntrAmountCalculator {
	
	public   float  calcSimpleIntrAmount(float pAmt,float time){
		
		System.out.println("IntrAmountCalculator::calcSimpleIntrAmount(-,-)");
        return (pAmt*2*time)/100.0f;
     }

	//public abstract  float  calcSimpleIntrAmount(float pAmt,float time);
}

<bean id="iac"  class="com.nt.beans.IntrAmountCalculator">
      <replaced-method name="calcSimpleIntrAmount"  replacer="csirmr">
         <arg-type >float</arg-type>
         <arg-type >float</arg-type>
      </replaced-method>
  </bean>
   
<bean id="csirmr"  class="com.nt.beans.CalcSimpleIntrAmountMethodReplacer">
       <constructor-arg  value="1.0"/>
   </bean>

public class CalcSimpleIntrAmountMethodReplacer implements MethodReplacer {
	private  float rate;
	
	 public CalcSimpleIntrAmountMethodReplacer(float rate) {
		this.rate = rate;
	}

	public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
		System.out.println("MethodReplacer::: reimplement(-,-,-)");
		  float pAmt=0.0f , time=0.0f;
		  pAmt=(Float)args[0];
		  time=(Float)args[1];
		  return (pAmt*rate*time)/100.0f;
	}
	
	 
}	 

**Important Points:
-------------------

1)The methods that you want to replace should not be the "final static"(This method can't be ovveriden in the subclass)

2) Even though you can't write the replacement logics for multiple methods in the single "reImplement()" by using the if conditions it is recommended to    take the separate method replacer class for the every method.


Internals:: IOC conatiner creates the subclass for the mainbean class Like Bank is Bank$$CGLIB.. By using the CGLib library internally.. In this class business method(cakcIntrAmt() ) will be oveeriden. In the method definiton the object of method replacer will be accessed and reImplement() will be called

Due to this new logic will be exeucted when the client calls the ctx.getBean() or factory.getBean() the above generated subclass object will be returned..


Various Injection:
-----------------

1) SetterInjection
2) Constructor Injection
3) Aware Injection/Contextual Dependency lookup/Interface Injection
4) Method Injection(Method replacer)
5) Lookup Method Injection


Bean Post Processor:
--------------------

Assigning some values to the bean properties after the injection is called post processing..We can do this post processing inside the bean class and specfic to bean class by using the custom init method or intializing Beans afterPropertiesSet() method..

If we want to apply the common post processing logic for multiple beans that to being from the outsisde of the bean class then we can use BeanPostProcessor

The beanPost processor executes for all the beans that are configured in the Spring Bean file.To develop the BeanPostProcessor we need to take a class that implements BeanPostProcessor and should provide the implementation for the 2 methods..

postProcessorBeforeIntialization(Obect bean,Spring beanId) Executes before the afterPropertiesSet() for the every bean class.

postProcessorAfterIntialization(Obect bean,Spring beanId) Executes after the custom init() for the every bean class configured inside the SpringBean File..

This concept is useful for developing the Custom postprocess/intialization logic common for all the beans in one class.

If we configure the BeanPostProcessor as the Spring bean then ApplicationContext can recognise.. But with BeanFactory we should do some extra configurations...

factory=new XmlBeanFactory(new ClassPathResource("com/nt/cfgs/applicationContext.xml"));	((ConfigurableListableBeanFactory)factory).addBeanPostProcessor(new PersonBOPostProcessor());


Bean PostProcessor gets applied for the Singleton and ProtoType beans also:
--------------------------------------------------------------------------

 <bean id="dao"  class="com.nt.dao.CollegeDAOImpl" scope="singleton"/>
  
  <bean id="stBO"  class="com.nt.bo.StudentBO"  scope="prototype"/>
  <bean id="empBO"  class="com.nt.bo.EmployeeBO" scope="prototype"/>
  
  <bean id="service"  class="com.nt.service.CollegeServiceImpl"   scope="singleton">
      <constructor-arg ref="dao"/>
      <lookup-method name="getStudentBO"  bean="stBO"/>
      <lookup-method name="getEmployeeBO"  bean="empBO"/>
  </bean>
  
   <bean id="pbbpp" class="com.nt.bpp.PersonBOPostProcessor"/>


Recognising the Annotations using the context:componentScan

In the realtime the BeanPostProcessor Will be used to place the common post process intialization logic that is required for the multiple beans assigning the systemdate as DOJ, or last modificationDate or dateofUpdation and etc.. This concept is useful towards the auditing activity

While working with ApplicationContextContainer if we just configure the BeanPostProcessor class in the xml file as SpringBean then container recognises and use that as the BeanPostProcessor..While working with BeanFactory we have to register BeanPostProcessor explicitly

//		factory=new XmlBeanFactory(new ClassPathResource("com/nt/cfg/applicationContext.xml"));	
//	    ((ConfigurableListableBeanFactory)factory).addBeanPostProcessor(new PersonBOPostProcessor());


Bean LifeCycle w.r.t to BeanFactoryContainer:
--------------------------------------------

Instiantiate

Populate Properties(Using the constructor/SetterInjection)

BeanNameAware's setBeanName()

BeanFactoryAware setBeanFactory()

PreIntialization() BeanPostProcessors

IntalizingBeans afterPropertiesSet()

Call the custom init() method

PostIntialization BeanPostProcessor
	|
	|
Bean is ready to use now
--------------------------------------------------------------------------------------
Container is Shutdown

Disposable Bean's destroy()

Call the custom destroy() method


**If the underlying container is ApplicationContext container it can inject both the BeanFactory ApplicationContext Objects to spring bean through the XXAwareInjections.If the bean class implements the factory-bean interface/factory-method attribute is configured in the bean tag then the container doesn't create the given bean class Object..

**Container creates/gets resultant object and keeps that resultant Object with configured bean Id.

	

Bean LifeCycle w.r.t to ApplicationContextContainer:
---------------------------------------------------

Instiantiate

Populate Properties(Using the constructor/SetterInjection)

BeanNameAware's setBeanName()

BeanFactoryAware setBeanFactory()

ApplicationContextAware's setApplicationContext()    *****

PreIntialization() BeanPostProcessors

IntalizingBeans afterPropertiesSet()

Call the custom init() method

PostIntialization BeanPostProcessor
	|
	|
Bean is ready to use now
--------------------------------------------------------------------------------------
Container is Shutdown

Disposable Bean's destroy()

Call the custom destroy() method


Complete Internal flow of the core module:
------------------------------------------

1) Programmer creates the BeanFactory Object 2) Given Spring bean configuration file will be located and it will be verified whether documents is well formed document or valid document.3) Creates the inmemeory logical IOC container in the jvm's memory.4)Reads the spring bean configuration file entries and 
creates an inmemory metadata having all the configuration.5) Client App calls factory.getBean("id") method..6) Loads the bean class from the inmemory meta data based on the given beanId and instantiates that bean based on the constructor injection configuration..
7)Keep the bean class Object in the specified scope..(If the cyclic dependency is configured then Bean Instantiation gets failed.)
8) Perfoms the setter injection based on configuration by perfoming the dependency-check
9)Perfoms the Aware Injections based on the AwareInterfaces that is implemented by the SpringBean
10)Calls the postProcessBeforeIntialization() if the beanPostProcessor is added..
11)Calls the afterPropertiesSet() if the IntializationBean(I) is added.
12)calls the custom init method if the "init-method" attribute is specified.
13)Calls the postProcessAfterIntialization()
14)Returns the bean Class Objects to the client application

***)If the ApplicationContext Object is created the steps(6-14) will be taken place automatically without calling the getBean() for the SingletonScopes...

***)If the <lookup-method> or<replaced-method> tag is configured insdie the <bean> tags container doesn't create the Object given BeanClass.. It creates the Object for the Subclass of the bean class which is generated by the IOC container..



BeanFactoryPostProcessors:
-------------------------

BeanPostProcessor is useful to write the postProcess Intialization logics with multiple Beans..BeanFactoryPostProcessors is useful to add the extra configurations by modifying the inmemory metadata after the creation of the IOC container and before the accessing the bean Object using the getBean()

It acts as the extension/hook for the IOC container to add the extra configuration without touching the xml file..It modifies the inmemory data of IOC container dynamically at runtime after the IOC container creation and before the bean class Object is accessed..To develop the Custom BeanFactoryPostprocessor we need to devleop the class implementing BeanFactoryPostprocessor(I).

Spring has lots of predefined BeanFatoryPostprocessor like PropertyPlaceHolderConfigurer.. This class modifies the inMemory meta data by replacing the placeholders ${} with the values created from properties file..

ApplicationContext Object based IOCcontainer automatically recognises BeanFactoryPostProcessor that is configured in the xml file, but for the BeanFactory Object based IOC container we need to register explicitly

By default we cannot work with properties file and PlaceHolder using the BeanFactoryContainer. But we can make it working by registering the PropertyPlaceHolderConfigurer as the beanFactoryPostProcessor

BeanFactory factory=new XmlBeanFactory(new FileSystemResource("applicationContext.xml"));

BeanFactoryPostProcessor bfpp=factory.getBean("PPC",PropertyPlaceHolderConfigurer.class);

bfpp.postProcessBeanFactory((ConfigurableListableBeanFactory)factory)


Property Editor:
---------------

In Spring we use the setter & consconstructor injection to assign the values to the bean properties. In Spring bean configuration file we configure those dependants values as the String values, but theyy will be converted to int,long,float,Date etc.. values as required for the bean properties automatically.

For this Spring internally uses the PropertyEditors to convert the String into the appropriate values..All the property Editors are the classes implementing from java.bean.PropertyEditor(I)..Builtin Property Editors:  StringArrayPropertyEditor ByteArrayPropertyEditor DateFormatPropertyEdior etc...

public class AadharDetails {
	
	private String name;
	private long uid;
	private char gender;
	private Date   dob;
	private float  age;
	private File  photoPath;
	private String[] verifiers;
	private  boolean isSingle;
	private URL  googleURL;

}


 <bean id="aadhar"  class="com.nt.beans.AadharDetails">
     <property name="name" value="raja"/>
     <property name="age" value="30"/>
     <property name="gender"  value="M"/>
     <property name="googleURL" value="https://google.co.in/search"/>
     <property name="uid" value="545454545455"/>
     <property name="dob" value="12-26-1990"/>
     <property name="photoPath" value="c:/abc/xyz/james.png"/>
     <property name="verifiers"  value="modi,amitSha"/>
     <property name="isSingle"  value="true"/>
</bean>


CustomPropertyEditor:
--------------------

public class LoanDetails {
	
	private float pAmt;
	private float rate;
	private float time;
}

public class BankIntrAmountCalculator {
	
	private LoanDetails  details;
}

<!-- <bean id="ld"  class="com.nt.beans.LoanDetails">
      <constructor-arg name="pAmt"  value="100000"/>
      <constructor-arg name="rate"  value="2"/>
      <constructor-arg name="time"  value="12"/>
  </bean> 
  
  
  <bean id="biac"  class="com.nt.beans.BankIntrAmountCalculator">
      <property name="details"  ref="ld"/>
    </bean>-->
   
   <bean id="biac"  class="com.nt.beans.BankIntrAmountCalculator">
      <property name="details"  value="100000,12,2"/>
    </bean>	


public class CustomLoanDetailsEditor extends PropertyEditorSupport {

	 @Override
	public void setAsText(String text) throws IllegalArgumentException {
		 float pAmt=0.0f,rate=0.0f,time=0.0f;
		 LoanDetails details=null;
		 //get values from property (text)
		 pAmt=Float.parseFloat(text.substring(0,text.indexOf(',')));
		 time=Float.parseFloat(text.substring(text.indexOf(',')+1, text.lastIndexOf(',')));
		 rate=Float.parseFloat(text.substring(text.lastIndexOf(',')+1, text.length()));
		 System.out.println(pAmt+"  "+time+"  "+rate);
		 //create LoanDetails class object
		 details=new LoanDetails(pAmt,time,rate);
		 //set value to Property
		 setValue(details);
	}
}

While working the BeanFactoryContainer or the DefaultListableBeanFactory we need to register the PropertyEditorRegistar Seprately
------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new XmlBeanFactory(new ClassPathResource("com/cfgs/applicationContext.xml"));
		   //add Custom PERegistart to IOC container
		 
		 ((ConfigurableListableBeanFactory)factory).addPropertyEditorRegistrar(new MyPERegistar());
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
	 }
	 
	 private static class MyPERegistar implements PropertyEditorRegistrar{

		@Override
		public void registerCustomEditors(PropertyEditorRegistry peRegistry) {
			 peRegistry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
		}//method
	 }//inner class
}//outer class

------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new DefaultListableBeanFactory();
		  reader=new XmlBeanDefinitionReader(factory);
		  reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		   //add Custom PERegistart to IOC container
		   factory.addPropertyEditorRegistrar(new PropertyEditorRegistrar(){

			@Override
			public void registerCustomEditors(PropertyEditorRegistry registry) {
				registry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
			}
		   }
		   );
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
	 }
------------------------------------------------------------------------------------------------------------------------------------------------------------
 factory=new DefaultListableBeanFactory();
		  reader=new XmlBeanDefinitionReader(factory);
		  reader.loadBeanDefinitions("com/cfg/applicationContext.xml");
		   //add Custom PERegistart to IOC container
		  factory.addPropertyEditorRegistrar(registry->{
			  registry.registerCustomEditor(LoanDetails.class,new CustomLoanDetailsEditor());
		  });
		 //get Bean 
		 bank=factory.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());

------------------------------------------------------------------------------------------------------------------------------------------------------------
While working with the ApplicationContext context we just need to configure the CustomEditorConfigurer Bean in the applicationContext.xml:

    <bean id="cec"  class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
          <map>
             <entry key="com.nt.beans.LoanDetails" value="com.nt.editors.CustomLoanDetailsEditor"/>
          </map>
        </property>
    </bean>

 ApplicationContext ctx=null;		 
		 BankIntrAmountCalculator bank=null;
		 //create  IOC container
		  ctx=new ClassPathXmlApplicationContext("com/cfgs/applicationContext.xml");
		 //get Bean 
		 bank=ctx.getBean("biac",BankIntrAmountCalculator.class);
		 
		 System.out.println("Intr Amount::"+bank.calcSimpleIntrAmount());
		 
		 //close container
		 ((AbstractApplicationContext) ctx).close();

------------------------------------------------------------------------------------------------------------------------------------------------------------
 <bean id="cec"  class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
          <map>
             <entry key="com.nt.beans.LoanDetails" value="com.nt.editors.CustomLoanDetailsEditor"/>
          </map>
        </property>
    </bean>

factory=new DefaultListableBeanFactory();
reader=new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions("com/nt/cfgs/applicationContext.xml");
//Get CustomEditorConfigurer Bean(BFPP) & register
processor=factory.getBean("cec",BeanFactoryPostProcessor.class);
processor.postProcessBeanFactory(factory);

------------------------------------------------------------------------------------------------------------------------------------------------------------

					Spring Core Annotations:

Annotations: Data about the data and code about the code is called the MetaData..Annotations are java statements to perfom the metadata operations in the .java files.. Annotations are alternate for the xml files to perfom the metadata,resource configuration operations. XML files gives the bad perfomance because the xml parsers are heavy to process the xml documents..

Annotations donot provide flexibility of modification but provide the good perfomance..

Annotations for the documentation are from JDK 1.0..Annotations for the programming are introduced from the JDK 1.5. We can apply the annotations at the different level class level, Method level, field level and Param level..The annotations are used by the compilers containers AnnotationProcessors JRE etc..

Some annotations provide the instructions to compiler but no effect will be there at Runtime.. 
@author @Since etc.. @override tells the inherited methods of the classes/interfaces as special items..

Some annotations are useful to mark the classes/interfaces as the Special items..
@Entity makes the ordinary JavaBean as hibernate/domain class
@WebServlet --->Makes the class as the Servlet Component..

Some annotations are useful to generate new classes using the tools dynamically based on the given class code..Eg: @WebService

All the java technologies/frameworks designed after the jdk1.5 are supporting the Annotations.

*****If we override the certain settings using the Annotations and xml file settings done in xml file will override the settings done through Annotations...

Spring Annotations:
-------------------

Spring 2.0 onwards there is support for annotations and more annotations are added incrementally in the next versions..In Spring programming we can instruct the IOC container to recognise the annotations only through xml file..We cannot use annotations to make the Predefined classses as the Spring Beans..To confgure such classes we need to take the help of XML..

@Required: To make the dependency injection(setterinjection) mandatory on properties we can use the dependency check activity..But it is removed from Spring 2.5 because it doesn't allow the programmer to enable the restriction on the specific properties.. It allows the programmer to enable the restriction on the group of properties like "simple" "object" "all".. To overcome this probelm we can use @Required..


The BeanPostProcessor of every Annotation contains the logic to recognize the annotation and to provide the functionality for the annotation. But configuring the BeanPostprocessor of every annotation is the complex process.To overcome this problem we use the <context:annotation-config/> tag.
To work with this tag import the context schema namespace in the xml..


@Required is Deprecated from the Spring 5.x:
--------------------------------------------

While working with Application Context it is not required to configure the BeanPostProcessor of Annotation in the xml file..

***While working with the DefaultListableBeanFactory we need to register the BeanPostProcessor of Annotation explicitly..

  </bean>
    <bean id="requiredAnnconfig" class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/> 
   
   <context:annotation-config/>
   
while working with the <context:annotation-config/> tag we need to add the SpringAOP version jar into the buildpath..

factory=new DefaultListableBeanFactory();
reader=new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions("com/cfgs/applicationContext.xml");
//register BPP
//factory.addBeanPostProcessor(new RequiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(factory.getBean("requiredAnnconfig",BeanPostProcessor.class));
//get Bean
per=factory.getBean("per",Person.class)



@AutoWired: 

Given to perfom the byType byName and constructor mode of autowiring..This annotation can be applied at the Filed Level Setter method level,Constructor level and aribitary method level also

If the dependant bean is not available to perfom the dependency injection through autowiring the exception will be raised when the required is 
true.. The deafult value is true.. Null will be assigned if the required=false and dependant bean configuration is not available(No Exception is raised)

We cannot apply the AutoWired annotation on the top of the zero param constructor..At max only 1 constructor can have the @Autowired annotation...When the @Autowired annotation is placed on the top of the field or setter method or the aribtary method the byType mode of autowiring will takes place... When the same annotation is placed on the Constructor then constructor mode of autowiring will takes place..

@Qualifier:: While perfoming the byType mode of autowiring there is a possibility of getting the ambiguity if multiple depndant beans are found to inect into target class. Inorder to overcome this problem we need to use @Qualifier annotation which makes the IOC container to perfom the byName mode of autowiring


@Component @Service @Repository @Controller:
--------------------------------------------

The above annotations are called as the SteroType annotations, because all the 4 type of annotations are having the same purpose with the minor change..

We can use all the 4 annotations to configure the java classes as the Spring beans..

@Component: Generic purpose stero type annotation to configure any java classes as the Spring beans..Exposes the given java class as the Spring bean to IOC conatiner.

@Service:Specification of the @Component, useful to configure the java classes of the service layer..As of now no special behaviour so it is same as Component

@Repository:Specification of the @Component, useful to configure the dao classes of the Repository layer.Capable of translating the one form of excpetion to the another form of exception..

@Controller:Specification of the @Component, useful to configure the classes as the controller of the Spring mvc app to process the request given by the clients..

<context:component-scan base-package="com.nt.beans"/> To identify the Spring beans that are annotated with the above annotations..
<context:annotation-config/> If you configure the <context:component-scan/> not required to configure <context:annotation-config/> all anotations benPostProcessors will be automatically configured..


Java Config Annotations: If you the @Component @Autowired etc.. are the Spring supplied annotations, if we use this annotations of the code of spring bean becomes tightly coupled code to the Spring Framework..This kills the non invasive feature of the Spring f/w.For overcoming these problem we use the java config annotations given by the JSE and JEE module..For these annotations functiaonality will be given by the container and frameworks that we are using..

For exmple for @inject spring provides its functionality and EJB also provides its functionality so when we change the F/w we can still depend on the same Annotations.. These annotations are provided as part of J2SE and JEE specifications but the implementation will be provided by the different servers and frameworks.. If we change the Runtime libraries of App we can still use the same annotations inside the classes.


@Inject: It is given inside the JEE specification inside the javx.inject package having the ability to perfom byname,bytype/constructor mode of autowiring..

Equal to @Autowired but the difference is there is no Required Parameter..

@Inject is java config anntation so Spring APP becomes the Non Invasive Framework..


@Inject can be applied at the field level method(setter/orbitory) or the constructor level.. To work with @Inject & @Named kind of JavaConfig annotations we need to add the javax.inject.jar files.. Total Jar Files:: IOCLib+SpringAOP.jar+javax.inject.jar


@Named:: It is the Java Config annotation of 'javax.inject' package of Jee specification..This anotation can be used in the two ways:

1)To resolve the ambiguity problem that is raised while perfoming the byType mode of autowiring..It is alternate to @Qualifier can be used along with the @Inject @Resource @Autowired..

2)To configure or mark the java classes as the Spring beans as alternate to the Spring specific annotations like @Component etcc....

@Resource: It is the JDk supplied Annotation of javax.annotation package.. Can be used to perfom the byType,byName mode of Autowiring.. Can be applied at the filed, method(setter/orbitory method) level.. By using the param attribute of annotation we can perfom the byName mode of autowiring..


****Note:: Ambiguity problem cannot be handled by the @Named Annotation instead you can use the @Qualifier or the @Resource Annotation

/**@Named cannot handle if there are multiple beans*/
	
//@Inject @Named("engine") private Engine engg;


Differences between the @Autowired @Inject @Resource::
-----------------------------------------------------

@Autowired 					@Inject						@Resource

Spring Annotation				JEE javaConfig					JavaConfig Annotation

Supports byType,byName				Supports byType,byName				Supports byType and byName
Constructor mode of Wiring			Constructor mode of Wiring

Makes Spring Bean class as			Non INvasive					Non INvasive
Invasive

Param Required is available			Non_Param					Param name is available

AmbiguityProblem:@Qualifer use			@Named @Qualifier can be used			We can use the @Named or name param available to resolve


Java Config Annotations for configuring the BeanLifeCycle Configurations: @PostConstruct & @PreDestroy
------------------------------------------------------------------------

to configure the normal methods as custom destroy/init methods both methods should have the following signature:

public void <method>(){}

@Scope:: Spring Annotation which can be applied on the class to specify the SpringBean scope


Working with Properties file in the Annotation Environment:
----------------------------------------------------------

To detect the classes and recognise the them as Spring beans through Annotations we can use the <context:component-scan> tag.

To detect the specified properties file that is configured through Annotation we can use <context:property-placeholder> tag..To inject the values of the properties file to bean properties we need to specify the keys of properties file through placeHolder ${key}..

@Named("dao")
public class DBOperationsDAO{

	@Value("${jdbc.driver}") private String driver;
}

<context:property-placeholder location="DB.properties"/>

Working with <context:property-placeholder> tag is equal to the working with PropertyPlaceHolderConfigurer Bean class of Spring API..


Developing the Spring Core Module Without XML File:
---------------------------------------------------

For this we need to use the AnnotationConfigApplicationContext to create the IOC container by specifying the Configuration class.The java class that contains the methods to create and return the bean class objects is called as the Configuration class..We @Configuration to configure the ordinary java class as the Configuration class. We use @Bean on the top of the configuration class methods which produces the Objects(To configure those objects as Bean we use the @Bean)

@Bean @Lazy @Scope @DependsOn 

All the methods of the Configuration class that are annotated with @Bean will be executed automatically, the moment IOC container is created by Specifying the Configuration Class..If you want to delay the certain method execution until the ctx.getBean() is called then use the @Lazy Annotation..In order to create the Bean Class Object only after the creating another bean class Object then we can go for the @DependsOn Annotation..

Bean instantiation takes place when the IOC container is created is called as the EagerInstantiation.. Bean Instantiation takes place only when ctx.getBean is invoked is called as the Lazy Instantiation...


Method Replacer using the Annotations:

public  class BankLoanMgmt {
	
	public float calculateIntrestAmount(float pAmt,float rate,float time) {
		 
		System.out.println("BankLoanMgmt.calculateIntrestAmount() ::: compound Intrest Amount");
		
		return  (float)((pAmt*Math.pow(1+rate/100, time))-pAmt);
	}

}

@Component("bankCIAR")

public class BankLoanMgmt_CaculateIntrestAmountReplacer implements MethodReplacer {

	@Override
	
	public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
		
		System.out.println("BankLoanMgmt_CaculateIntrestAmountReplacer.reimplement(-,-,-) :: simple Intrest amount");
		float pAmt=0.0f;
		float time=0.0f;
		float rate=0.0f;
		
		//get  target /original method args values
		
		pAmt=(float)args[0];
		rate=(float)args[1];
		time=(float)args[2];
		//write new logics  (Simple Intrest amount)
		return pAmt * rate* time/100.0f;
	}

}



<bean id="bank"  class="com.nt.target.BankLoanMgmt">
       <replaced-method  name="calculateIntrestAmount"  replacer="bankCIAR"> *****We can use the bean that is configured with @Component("bankCIAR")
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
       </replaced-method> 
    </bean>
    
   <context:component-scan base-package="com.nt.replacer"/>	


100P AnnotationCode:
-------------------


@Configuration
@ImportResource("com/nt/cfgs/applicationContext.xml")				Just avoiding the <context/> tags heree.....
@ComponentScan(basePackages = "com.nt.replacer")
public class AppConfig {

}

<!-- target/main class cfg -->
    <bean id="bank"  class="com.nt.target.BankLoanMgmt">
        <replaced-method  name="calculateIntrestAmount"  replacer="bankCIAR">
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
            <arg-type>float</arg-type>
       </replaced-method>  
    </bean>
    
</beans>



Annotation Based code to collect the values from the Properties files:
-----------------------------------------------------------------------
@Configuration
@ComponentScan(basePackages = "com.nt.dao")							<context:component-scan/> Avoids 
@PropertySource(value = {"com/nt/commons/jdbc.properties",
		                                       "com/nt/commons/jdbc1.properties"})
public class PersistenceConfig {

	@Autowired
	private Environment env;

	@Bean(name="hkDs")
	public  DataSource createDS() {					Third partyBeans are configured
		HikariDataSource  hkDs=null;
		hkDs=new HikariDataSource();
		hkDs.setDriverClassName(env.getRequiredProperty("jdbc.driver"));
		hkDs.setJdbcUrl(env.getRequiredProperty("jdbc.url"));
		hkDs.setUsername(env.getRequiredProperty("jdbc.user"));
		hkDs.setPassword(env.getRequiredProperty("jdbc.pwd"));
		hkDs.setMinimumIdle(Integer.parseInt(env.getRequiredProperty("pool.minsize")));
		hkDs.setMaximumPoolSize(Integer.parseInt(env.getRequiredProperty("pool.maxsize")));
		System.out.println("system property ::"+env.getProperty("os.name"));
		return hkDs;
	}
}


Nested Container example with AnnotationConfigApplicationContext:
-----------------------------------------------------------------
parentCtx=new AnnotationConfigApplicationContext(BusinessAppConfig.class);
childCtx=new AnnotationConfigApplicationContext();
childCtx.setParent(parentCtx);
childCtx.register(PresentationAppConfig.class);
childCtx.refresh();  //To perform pre-instantation of singletonscope beans.

controller=childCtx.getBean("controller",MainController.class);


SpringBoot Example:
------------------

All the some of the ThirdParty Classes (asBeans) will also be automtically configured,without even writing the code based on the Classpath jar files..

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		
//		SpringApplication.run(DemoApplication.class, args);
		
		ApplicationContext ctx=null;
		WishMessageGenerator generator=null;
		//get IOC container
		ctx=SpringApplication.run(DemoApplication.class, args);
		
		System.out.println(ctx.getClass());	 //class org.springframework.context.annotation.AnnotationConfigApplicationContext							
		//get Spring bean class object
		generator=ctx.getBean("wmg",WishMessageGenerator.class);
		//invoke method
		System.out.println(generator.generateWishMessage("raja"));
		//close container
		((AbstractApplicationContext) ctx).close();
		
	}

}

									Spring JDBC:
									------------

Where should we use the JDBC & where should we use Hibernate?

While working with JDBC if you want to process huge amount of records then we need to deal with Single ResultSetObject..While working with Hibernate, if we want to take process huge amount of records then we need to take the multiple objects representing the multiple records..This is the problem & it may crash the system, while creating huge amount of Objects..

Use JDBC for offline application that deals with the huge amount of data and where we don't need the database portability feature.(Changing the DB Software with modifying the codeee..)Ex:Storing and managing the sensus details, political party membership details by perfoming the validation and also correction 

While developing the online(internet applications) that deals with the limited amount of personalized data then we use the Hibernate..

Ex: Online Shopping Mobile recharge Online etc..

While developing the internet application that perfoms the batch processing of huge amount of data then we use the JDBC technology..

Ex: Mobile number activation application that activates the set of numbers at a time..

*** Spring JDBC provides the abstraction over the plain JDBC and simplifies persistence logic development..Instead of using the plain jdbc in offline applications & internet applications that deals with huge amount of data through batch processing it is recommended to use the Spring JDBC..

Plain JDBC code::
----------------

Register the JDBC driver
Establish the connection
Create Statement
Send & execute the SQL Query
Gather results & process Results
Exception Handling
Close the JDBC Objects...

Spring JDBC App:
---------------

Configure & get the JDBC Template Class Object 
Send & execute the SQL Query
Gather results & process results..


Limitations with Plain JDBC:
---------------------------

> Boiler Plate Code problem > Exception Handling is mandatory > Processing the resultset to get the result in desired type is a complex process.
> No support for the proper Tanscation Management


Advanatges of Spring JDBC:
-------------------------

Solves the Boiler plate code problem..Makes the programmer to take care of application specific logics..Raises the unchecked exceptions(subclasses of the DataAccessException class & itself) so the exception is optional to catch and handle..it internally uses the exception rethrowing concepts to convert the checked exception(SQLException) into Uncheked Exception..

Gives various methods to get the records of the resultSet object in the Desired Type..Takes care of opening the connection & close the connection activities...supports the both positional & named params in the SQL Query..

Allows to use the callback interfaces to develop the more & more customized persistence logic development using the plain JDBC code..

Action 							Programmer 						Spring JDBC
-----------------------------------------------------------------------------------------------------------------------------
Configuring the Datasource				Yes
Creating/getting connection											Yes
Creating Statement												Yes
Preparing the SQL Query with Params			Yes
Sending Executing SQL Query in DB S/W			Yes
Iterating through ResultSet if needed.										Yes
Exception Handling												Yes
Transaction Management												Yes
Close the JDBC Objects												Yes


Spring JDBC/ORM modules internally uses the multiple other technologies/Frameworks to develop the persistence logics but translate the exceptions of underlying technology/framework into Spring DataAcessException Hirerachy..

There are five methodlogies to develop the persistence logics in Spring JDBC..

JDBC Template:

1)NamedParameterJDBCTemplate
2)SimpleJDBCTemplate(Removed from Spring 4.0)
3)SimpleJDBCInsert,SimpleJDBCCall
4)Modelling JDBC operations as Java Objects(Mapping the SQL Operations as subclass using the SQLQuery & SQLUpdate Classes..(JDO Style))

Connection Pool Based Connection
--------------------------------
While working with any technique Spring JDBC we need to use the JDBC connection to interact with D/B software.It is recommended to use the jdbc connection pool based connection instead of the direct connection..Don't use the Spring builtin classes like DriverManagerDatasource,SingletonConnectionDatasource etc..to work with spring jdbc connection pool because those classes actually doesn't pool the connection objects more over creates the jdbc connection objects on demand..

If our Spring API is standalone app running outside the server then use the Third party supplied JDBC Connection Pool like C3P0 or apacheDBCp.
If our spring app is deployable in the server then use the jdbc connection pool

Using JDBCTemplate:
------------------

This is the central class of the Spring JDBC provides the abstraction layer on the plain jdbc and simplifies the persistence logic development.. This class takes care of common workflow activities of jdbc programming like opening connection,creating statement,closing connection and etc...but makes the programmer to just provide the SQL query and extract results..This class translates the JDBC generated SQLExceptions into Spring specific unchecked exceptions like DataAccessException.. 

This avoids the programmer to avoid the common errors in ApplicationDevelopment like fogetting to close the JDBC objects.. To create the JDBCTemplate class object we need the jdbc datasource object.. We generally configure the JDBCTemplate class in the Spring Bean configuration file and use that to inject that object into the DAO Class...

There are 2 approches to work with JdbcTemplate:
-----------------------------------------------

1) Using the direct methods(No need of JDbC code) 2)Using the call back interfaces(Need to write the plain jdbc code customized persistence logic)

Direct Methods of JDBCTemplate Class:

Select operations:
---------------

query() queryForXXX() methods:

queryForInt() queryForLong() To execute the query that gives the Single numeric value as result(Ex: select count(*) from student;)

queryForMap(): To execute the query that gives the single record.  select * from student where sno=1001

queryForObject():To execute the query and get the result into predefined BO class object.(Like numeric value, String )

queryForList(): To execute the query that gives multiple records. select * from student

queryForRowset(): To execute the query that gives the jdbc Rowset Object etc..

Note :: If the above methods are executed or called with one argument they internally uses the JDBC Simple Statement Object..

Note:: If the above methods are called with 2 or 3 arguments then they internally uses the JDBC PreparedStatement Object

For the nonselect operations:  update method..

For the Batch Updation:: batchupdate() method and many more..


Example::

private  static final String  GET_EMPS_COUNT="SELECT COUNT(*) FROM EMP";
	private static final String GET_EMP_NAME="SELECT ENAME FROM EMP WHERE ENO=?";
	private  static final String  GET_EMPDETAILS_BY_NO=
			"SELECT ENO,ENAME,SALARY,JOB,DEPTNO FROM EMP WHERE ENO=?";
	private  static final String  GET_EMPDETAILS_BY_DESGS=
			"SELECT ENO,ENAME,SALARY,JOB,DEPTNO FROM EMP WHERE JOB IN(?,?) ORDER BY JOB";
	private  static final String  INSERT_EMP=
			"INSERT INTO EMP(ENO,ENAME,JOB,SALARY) VALUES(?,?,?,?)";
	private  static final String  ADD_BONUS_EMP_BY_DESG=
			"UPDATE EMP SET SALARY=SALARY+? WHERE JOB=?";
	
@Override
	public int getEmpsCount() {
       int count=0;
        count=jt.queryForObject(GET_EMPS_COUNT,Integer.class);
        return count;
	}
	
	@Override
	public String getEmpNameByNo(int eno) {
		return jt.queryForObject(GET_EMP_NAME,String.class,eno);
	}
	
	@Override
	public Map<String, Object> getEmpDetailsByNo(int no) {
		return jt.queryForMap(GET_EMPDETAILS_BY_NO, no);
	}
	
	@Override
	public List<Map<String, Object>> getEmpDetailsByDesgs(String desg1, String desg2) {
		return jt.queryForList(GET_EMPDETAILS_BY_DESGS, desg1,desg2);
		
	}
	
	@Override
	public int insertEmp(int eno,String ename, String desg, float salary) {
		return jt.update(INSERT_EMP, eno,ename,desg,(int)salary);
	}
	
	@Override
	public int addBonusToEmpByDesg(String desg, float bonus) {
		return jt.update(ADD_BONUS_EMP_BY_DESG,(int)bonus,desg);
	}


To provide the global visibility to Object or object refrence it will be placed in the jndi registry having the nick name. Evey web/appserver gives one builtin jndi registry. In server managed jdbc connection pool environment the ConnectionPool will be represented by the DataSource object and its refrence will be placed inside the jndi registry of server for the global visibility having the jndi name.. The apps deployed in the server or running outside the server can access the DatasourceObject refrence from the JNDI registry to get the connection object from the jdbc connection pool. In one server we can create the multiple connection pools representing the multiple databses..The client app that wants to use the connection pool can be there inside the server as the deployable servelt,jsp/EjB component.or can be outside the server as the StandAlone Application.

Witrespect to diagram:
----------------------

TL or PL or Admin makes the server to use the Type1/Type2/Type4 jdbc driver to interact with database software to create the server managed jdbc connection pool having the connection objects. TL/PL/Admin creates the Datasource Object representing the jdbc connection pool places that Datsource object refrence in the jndi registry having the jndi name for the global visibility


In Weblogic software we can create multiple domains and each domain acts as the 1 domain server.Multiple projects of the company uses multiple domain servers of the weblogic on one per project basis. i.e weblogic will be installed only once but we can have multiple domain servers...

Spring gives one builtin Factorybean class to get the object from the jndi registry based on the jndi-name.Bean is JNDIObjectFactoryBean 

While developing the eclipse based webapplications the jar files placed in the buildpath will not be moved to WEB-INF/lib directory directly..For that we need to do the deployment assembly seprately..

To deploy the eclipse webproject in Ntsp27 domain of weblogic.

While working with SpringJDBC in servlet then applicationContext should be object of ClassPathXmlApplicationContext..If it is FileSystemApplicationContext then it will not work..

***Procedure to create the JDBC Connection Pool for the Oracle in WebLogic Server in the Domainserver of GlassFish:

***Procedure to create the JDBC Connection Pool for the Oracle in GlassFish Server in the Domainserver of GlassFish:

***Procedure to create the JDBC Connection Pool for the Oracle in Tomcat Server:


Step1: Make sure tomcat-jdbc.jar file is avaialble in the <tomcat_home>/lib folder..This jar builtin file in tomcat but must be arranged separately for another versions of tomcat. Make sure the ojdbc6.jar is also made available in the server lib folder.

Step2: Place the <Resource> tag in context.xml file..Restart the server.

To use the above jdbc connection pool in web applications we need to place the jndi-name as shown: Java:/comp(prefix)/env/myPool(JNDI Name)

CallBack Interfaces:
--------------------

The method that is called by underlying jvm/container/server etc.. automatically and dynamically is called CallBack Method..The interface that contains such methods is called CallBack Interfaces..Spring provides lots of callback interfaces along with the lot of Template classes.. We can use this CallBack interfaces to write the customized logic to process data and get the data in the customized manner.

For example:queryForMap gives the single record in the form of map object having the column name as key as column values as database column value in map..
But industry standard is to get that record in the BOClass Object.. For this SPring gives the Rowmapper callBack interface.. Various CallBack interfaces of Spring JDBC are:

StatementCallBack--->Allows to work with statementObject
PrepareStatementCallBack CallableStatementCallBack
PrepareStatementCreator--->Provides an object to create the PreparedStatement
PreparedStatementSetter--->Provides the PreparedStatement Object to set the values to queryParam.
RowMapper--->To process the 1 record of ResultSet at a time..
ResultSetExtractor--->To process the multiple records of the ResulSet at a time..

Note:: The implementation Class methods of the CallBackInterfaces will be called by the JDBCTemplate Internally

LookOut for the DAOProj5-JdbcTemplateCallbackInterfaces: in the workspace
-------------------------------------------------------------------------

@Repository("studentDAO")
public class StudentDAOImpl implements StudentDAO{

	private static final String  GET_STUDENT_BY_NO=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SNO=?" ;
	private static final String  GET_STUDENTS_BY_CITIES=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SADD IN(?,?,?)" ;
	
	@Autowired
	private JdbcTemplate jt;

	@Override
	public StudentBO getStudentByNo(int no) {
		return jt.queryForObject(GET_STUDENT_BY_NO,new StudentMapper(),no);
	}
	
	private  static class  StudentMapper implements RowMapper<StudentBO>{

		@Override
		public StudentBO mapRow(ResultSet rs, int rowNum) throws SQLException {
			//convert   RS record to StudentBO class object
			StudentBO bo=new StudentBO();
			bo.setSno(rs.getInt(1));
			bo.setSname(rs.getString(2));
			bo.setSadd(rs.getString(3));
			bo.setAvg(rs.getFloat(4));
			return bo;
		}//mapRow(-,-)
	}//inner class
	
	
	@Override
	public List<StudentBO> getStudentsByCities(String city1, String city2, String city3) {
		
		return  jt.query(GET_STUDENTS_BY_CITIES, new StudentExtractor(),city1,city2,city3);
	
	}
	
	private  static class  StudentExtractor implements ResultSetExtractor<List<StudentBO>>{
		
		@Override
		public List<StudentBO> extractData(ResultSet rs) throws SQLException, DataAccessException {
			
			System.out.println("StudentDAOImpl.StudentExtractor.extractData(-)");
			List<StudentBO>  listBO=null;
			StudentBO bo=null;
			//copy  RS object records to  List of StudentBO collection
			listBO=new ArrayList<>();
			while(rs.next()) {
				//get each record into StudentBO class object
				bo=new StudentBO();
				bo.setSno(rs.getInt(1));
				bo.setSname(rs.getString(2));
				bo.setSadd(rs.getString(3));
				bo.setAvg(rs.getFloat(4));
				//add each BO class obj to List colleciton
				listBO.add(bo);
			}//while
			return listBO;
		}//extractData(-)
	}
	
	@Override
	public List<StudentBO> getStudentsByCities1(String city1, String city2, String city3) {
		 List<StudentBO> listBO=new ArrayList<>();
		 jt.query(GET_STUDENTS_BY_CITIES, new StudentCallBackHandler(listBO), city1,city2,city3);
		 return listBO;
	}
	
	private static class StudentCallBackHandler implements RowCallbackHandler{
		 private List<StudentBO> listBO;
		
		public StudentCallBackHandler(List<StudentBO> listBo) {
			
			this.listBO=listBo;
		}
		
		@Override
		public void processRow(ResultSet rs) throws SQLException {
			
			System.out.println("StudentDAOImpl.StudentCallbackHandler.processRow(-)");
			
			StudentBO bo=null;
			//covert RS record into BO clss object
			bo=new StudentBO();
			bo.setSno(rs.getInt(1));
			bo.setSname(rs.getString(2));
			bo.setSadd(rs.getString(3));
			bo.setAvg(rs.getFloat(4));
			listBO.add(bo);
		}
		
	}
}


Try to implement the same methods with the InnerClasses & with the LambdaExpressions..

@Repository("studentDAO3")
public class StudentDAOImpl3 implements StudentDAO{

	private static final String  GET_STUDENT_BY_NO=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SNO=?" ;
	private static final String  GET_STUDENTS_BY_CITIES=
			"SELECT SNO,SNAME,SADD,AVG FROM STUDENT WHERE SADD IN(?,?,?)" ;
	
	@Autowired
	private JdbcTemplate jt;

	
	@Override
	public StudentBO getStudentByNo(int no) {
		StudentBO bo1=null;
		bo1=jt.queryForObject(GET_STUDENT_BY_NO,   // arg1
									 new BeanPropertyRowMapper<StudentBO>(StudentBO.class),
				                              no //arg3 
				                              );
		return bo1;
	} //method

	@Override
	public List<StudentBO> getStudentsByCities(String city1, String city2, String city3) {
		List<StudentBO> listBO=null;
		BeanPropertyRowMapper<StudentBO> bprm=null;
		//create BeanPropertyRowMapper class obj  that hepls to copy each record into  one BO class obj
		bprm=new BeanPropertyRowMapper<StudentBO>(StudentBO.class);
		listBO=jt.query(GET_STUDENTS_BY_CITIES, //arg1
				                  new RowMapperResultSetExtractor<StudentBO>(bprm), //args2
				                   city1,city2,city3 //arg3 (Var args)
				                    );
		
		return listBO;
	}
	
	@Override
	public List<StudentBO> getStudentsByCities1(String city1, String city2, String city3) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
}









































































>>>>>>> origin/main
